// cmm_grammar.y:
// Initial version 2001.12.12 by doing
// Updated 2011.6.30 by shenyq
// Immigrated 2015.10.29 by doing

%parse-param {Lang *lang_context}

%{
// Don't be worried about the possible warnings.
// This file is generated by YACC.

#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#define YYSTACK_USE_ALLOCA      1

#include "cmm.h"
#include "cmm_buffer_new.h"
#include "cmm_efun.h"
#include "cmm_program.h"
#include "cmm_common_util.h"
#include "cmm_lang.h"
#include "cmm_lexer.h"
#include "cmm_register_allocator.h"
#include "cmm_value.h"

namespace cmm
{

#define isalunum(c) (isalnum(c) || (c) == '_')

#define MAX_COMPILER_ERRORS     64
#define YYDEBUG 0

#define malloc(size)    std_allocate_memory(size, "yacc", __FILE__, __LINE__);
#define free(ptr)       std_free_memory(ptr, "yacc", __FILE__, __LINE__);

#define yyerror         Lang::syntax_error
#define yyerrors        Lang::syntax_errors
#define yywarn          Lang::syntax_warn
#define yywarns         Lang::syntax_warns

#define _yyerror(str)   yyerror(lang_context, str)
#define _yyerrors(...)  yyerrors(lang_context, __VA_ARGS__)
#define _yywarn(str)    yywarn(lang_context, str)
#define _yywarns(...)   yywarns(lang_context, __VA_ARGS__)
#define _yystop()       Lang::syntax_stop(lang_context, ErrorCode::COMPILE_ERROR)

// Define the "yyparse" as a macro in case of name conflict with other
// files generated by YACC
#define yyparse         cmm_lang_parse
#define yylex           lang_context->m_lexer.lex_in

// New an AST node
#define NEW_AST_NODE(type)  LANG_NEW(lang_context, type, lang_context)

%}

/*
 * Token definitions.
 *
 * Appearing in the precedence declarations are:
 *      '+'  '-'  '/'  '*'  '%'
 *      '&'  '|'  '<'  '>'  '^'
 *      '~'  '?'
 *
 * Other single character tokens recognized in this grammar:
 *      '{'  '}'  ','  ';'  ':'
 *      '('  ')'  '['  ']'  '$'
 */

%token L_STRING L_NUMBER L_REAL
%token L_BASIC_TYPE
%token L_IDENTIFIER
%token L_LABEL
%token L_NIL
%token L_IS_REF

%token L_ADD_COMPONENT

%token L_INC L_DEC
%token L_ASSIGN
%token L_LAND L_LOR
%token L_LSH L_RSH
%token L_ORDER
%token L_NOT
%token L_REV
%token L_ADD L_SUB L_MUL L_DIV L_MOD
%token L_OR L_AND L_XOR
%token L_LT

%token L_BUILD
%token L_IF L_ELSE
%token L_SWITCH L_CASE L_DEFAULT L_RANGE L_DOT_DOT_DOT
%token L_WHILE L_DO L_FOR
%token L_LOOP L_UPTO L_DOWNTO L_EACH L_IN
%token L_BREAK L_CONTINUE
%token L_ARROW L_EXPAND_ARROW L_COLON_COLON
%token L_ARRAY_OPEN L_MAPPING_OPEN L_FUNCTION_OPEN
%token L_GOTO
%token L_CALL
%token L_RETURN
%token L_TRACE L_SHOUT
%token L_GLOBAL

%token L_TRY L_CATCH

%token L_PRIVATE L_PUBLIC
%token L_OVERRIDE L_NOMASK
%token L_STATIC
%token L_NOSAVE
%token L_CONST

%union
{
    Integer             number;
    Real                real;
    const char*         string;

    AstNode*            node;
    AstCase*            cases;
    AstDeclaration*     declares;
    AstExpr*            expression;
    AstExpr*            expr_list;
    AstFunction*        function;
    AstFunctionArg*     argument;
    AstFunctionArgsEx   arguments_ex;
    AstPrototype*       prototype;

    ValueType           basic_var_type;
    AstVarAttrib        var_attrib;
    AstVarType          var_type;
    AstFunctionAttrib   fun_attrib;

    int                 int_val;
    Op                  op;
}

/*
 * 'Dangling else' shift/reduce conflict is well known...
 *  define these precedences to shut yacc up.
 */

%nonassoc LOWER_THAN_ELSE
%nonassoc L_ELSE

/*
 * Operator precedence and associativity...
 * greatly simplify the grammar.
 */

%right L_ASSIGN
%right '?'
%right ':'
%left L_LOR
%left L_LAND
%left L_OR
%left L_XOR
%left L_AND
%left L_EQ L_NE
%left L_ORDER L_LT
%left L_LSH L_RSH
%left L_ADD L_SUB
%left L_MUL L_MOD L_DIV
%right L_REV
%right L_NOT
%left '.'
%left L_ARROW
%left '['
%nonassoc L_INC L_DEC

// Type declarations.

// These hold opcodes
%type <op>              L_ASSIGN L_ORDER

// These hold arbitrary numbers
%type <number>          L_NUMBER

// These hold a signal number (-1/+1)
%type <number>          to

// These hold a real number
%type <real>            L_REAL

// holds a string constant
%type <string>          L_STRING strings

// These hold a list of possible interpretations of an identifier
%type <string>          L_LABEL

// These hold a type
%type <var_type>        cast var_type

// These hold a basic type
%type <basic_var_type>  L_BASIC_TYPE

// These hold var type attrib
%type <var_attrib>      var_attrib optional_question_mark optional_and

// These hold a function type
%type <fun_attrib>      fun_attrib  fun_attribs

// These hold a string
%type <string>          L_IDENTIFIER identifier

// These hold a declaration of variable(s)
%type <declares>        declare_vars declare_1_var 

// These hold a serial of ast node
%type <node>            declarations single_declaration 
%type <node>            statement statements
%type <node>            add_component
%type <node>            block label
%type <node>            try_catch 
%type <node>            if loop optional_else_part
%type <node>            goto
%type <node>            switch
%type <node>            for do while
%type <node>            loop_init
%type <node>            trace shout
%type <node>            command
%type <expr_list>       mapping_pairs mapping_pair
%type <function>        function
%type <prototype>       prototype raw_prototype
%type <argument>        arg_list new_arg
%type <arguments_ex>    arguments_ex
%type <cases>           switch_block switch_block1 case
%type <expression>      expr0 comma_expression 
%type <expression>      expr_variable optional_assign possible_arguments
%type <node>            for_init
%type <expression>      for_cond for_step
%type <expression>      constant case_label
%type <expression>      element fun_call single_value catch

%%

all:
        statements
        {
            if (!lang_context->m_num_errors || $1)
            {
                // No error or got the AST
                lang_context->m_root = NEW_AST_NODE(AstRoot);
                lang_context->m_root->add_child($1);
            }
        }
    ;

statements:
        // empty
        {
            $$ = NEW_AST_NODE(AstStatements);
        }
    |
        statements statement
        {
            $1->add_child($2);
            $$ = $1;
        }
    |
        statements add_component
        {
            $$ = $1;
        }
    |
        statements function
        {
            // The function is put into table: m_functions
            $$ = $1;
        }
    |
        statements declarations ';' 
        {
            $1->add_child($2);
            $$ = $1;
        }
    |
        statements error
        {
            _yyerror("Illegal statement.");
            $$ = $1;
        }
    ;

block:
	    '{' statements '}'
        {
            $$ = $2;
        }
    ;

try_catch:
		L_TRY block L_CATCH block
		{
            // More to be added
		}
	;

label:
        identifier ':'
        {
            auto* node = NEW_AST_NODE(AstLabel);
            node->name = $1;
            $$ = node;
        }
    ;

statement:
        ';'
        {
            $$ = 0;
        }
    |
        single_value ';'
        {
            $$ = $1;
        }
    |   label
    |   block
    |   if
    |   for
	|   loop
    |   do
    |   while
	|	try_catch
    |   switch
    |   goto
	|   trace
    |   shout
    |
        L_BREAK ';'
        {
            auto* node = NEW_AST_NODE(AstGoto);
            node->goto_type = AstGotoType::AST_BREAK;
            node->loop_switch = lang_context->get_node_for_break();
            if (!node->loop_switch)
            {
                _yyerror("Break mismatched loop or switch.");
                $$ = 0;
            } else
                $$ = node;
        }
    |
        L_CONTINUE ';'
        {
            auto* node = NEW_AST_NODE(AstGoto);
            node->goto_type = AstGotoType::AST_CONTINUE;
            node->loop_switch = lang_context->get_node_for_continue();
            if (!node->loop_switch)
            {
                _yyerror("Continue mismatched loop or switch.");
                $$ = 0;
            } else
                $$ = node;
        }
    |
        L_RETURN ';'
        {
            auto* node = NEW_AST_NODE(AstReturn);
            node->expr = 0;
            $$ = node;
        }
    |
        L_RETURN single_value ';'
        {
            auto* node = NEW_AST_NODE(AstReturn);
            node->expr = $2;
            $$ = node;

            // change the entry function type
            if (lang_context->is_in_entry_function())
                lang_context->m_entry_function->prototype->ret_var_type.basic_var_type = MIXED;
        }
    |
        command
        {
            $$ = $1;
        }
    ;

add_component:
        L_ADD_COMPONENT strings ';' 
        {
            lang_context->add_component($2);
        }
    ;

function:
        prototype 
        {
            if (lang_context->is_in_entry_function())
                // At top, this is member function of current object
                $1->attrib |= AST_MEMBER_METHOD;

            auto* node = NEW_AST_NODE(AstFunction);
            node->prototype = $1;
            node->no = (FunctionNo)lang_context->m_functions.size();
            lang_context->m_functions.push_back(node);

            auto* prev = lang_context->m_in_function;
            lang_context->m_in_function = node;

            // Backup previous function
            $<function>1 = prev;
        }
        '{' statements '}'
        {
            auto* node = lang_context->m_in_function;
            node->body = $4;

            // Restore previous function context
            lang_context->m_in_function = $<function>1;

            $$ = node;
        }
    |
        prototype error
        {
            _yyerror("Bad function body, expected \"{ ... }\".");
            $$ = 0;
        }
    ;

prototype:
        fun_attribs raw_prototype
        {
            $2->attrib |= $1;
            $$ = $2;
        }
    |
        raw_prototype
        {
            $$ = $1;
        }
    ;

fun_attribs:
        fun_attrib
        {
            $$ = $1;
        }
    |
        fun_attribs fun_attrib
        {
            $$ = $1 | $2;            

            if ($$ != ~(AstFunctionAttrib)0)
            {
                if (($$ & AST_PRIVATE) && ($$ & AST_PUBLIC))
                {
                    $$ = ~(AstFunctionAttrib)0;
                    _yyerror("private conflict with public.");
                } 
            }
        }
    ;

fun_attrib:
        L_PRIVATE
        {
            $$ = AST_PRIVATE;
        }
    |
        L_PUBLIC
        {
            $$ = AST_PUBLIC;
        }
    |
        L_OVERRIDE
        {
            $$ = AST_OVERRIDE;
        }
    |
        L_NOMASK
        {
            $$ = AST_UNMASKABLE;
        }
    ;

raw_prototype:
        var_type identifier '(' arguments_ex ')'
        {
            // 构造函数结构
            auto* node = NEW_AST_NODE(AstPrototype);
            node->attrib = (AstFunctionAttrib)0;
            node->name = $2;

            // consider current attribute
            if (lang_context->m_current_attrib & AST_OVERRIDE)
                node->attrib |= AST_OVERRIDE;

            // constructor or destructor must be private
            if (strcmp($2, "create") == 0 || strcmp($2, "destruct") == 0)
                node->attrib |= AST_PRIVATE;

            node->ret_var_type = $1;
            node->arg_list = $4.arg_list;
            if ($4.ddd)
                node->attrib |= AST_RANDOM_ARG;

            $$ = node; 
        }
    ;

var_type:
        var_attrib L_BASIC_TYPE optional_question_mark
        {
            AstVarType var_type;
            var_type.basic_var_type = $2;
            var_type.var_attrib = $1 | $3;
            $$ = var_type;
        }
    ;

var_attrib:
		// Empty
		{
            $$ = (AstVarAttrib)0;
		}
	|
		L_NOSAVE var_attrib
		{
            $$ = AST_VAR_NO_SAVE | $2;
		}
    |
        L_CONST var_attrib
        {
            $$ = AST_VAR_CONST | $2;
        }
	;

arguments_ex:
        // empty
        {
            $$.arg_list = 0;
            $$.ddd = false;
        }
    |
        L_DOT_DOT_DOT
        {
            $$.arg_list = 0;
            $$.ddd = true;
        }
    |
        arg_list
        {
            $$.arg_list = $1;
            $$.ddd = false;
        }
    |
        arg_list L_DOT_DOT_DOT
        {
            $$.arg_list = $1;
            $$.ddd = true;
        }
    |
        arg_list ',' L_DOT_DOT_DOT
        {
            $$.arg_list = $1;
            $$.ddd = true;
        }
    ;

arg_list:
        new_arg
        {
            $$ = $1;
        }
    |
        arg_list ',' new_arg
        {
            if ($1 != 0)
            {
                // Check default value
                if ($1->default_value != 0 && $3->default_value == 0)
                    _yyerror("Bad argument, miss default value.\n");
            }
            $3->arg_no = (ArgNo)$1->get_sibling_count();
            $$ = (AstFunctionArg*)append_sibling_node($1, $3);
        }
    ;

new_arg:
        error
        {
            $$ = 0;
        }
    |
        var_type optional_and identifier optional_assign
        {
            if ($1.basic_var_type == TVOID || $1.basic_var_type == NIL)
			{
	            $$ = 0;
                _yyerror("Invalid argument type.");
            } else
            {
                $1.var_attrib = $1.var_attrib | $2;
                auto* node = NEW_AST_NODE(AstFunctionArg);
                node->name = $3;
                node->var_type = $1;
				node->default_value = $4;
                $$ = node;
            } 
        }
    ;

optional_and:
        // empty
        {
            $$ = (AstVarAttrib)0;
        }
    |
        '&'
        {
            $$ = AST_VAR_REF_ARGUMENT;
        }
    ;

optional_question_mark:
        // empty
        {
            $$ = (AstVarAttrib)0;
        }
    |
        '?'
        {
            $$ = AST_VAR_MAY_NIL;
        }
    ;

declarations:
        var_type declare_vars
        {
            if ($1.basic_var_type == TVOID || $1.basic_var_type == NIL)
                _yyerror("Invalid variable type.");

            if (($1.var_attrib & AST_VAR_MAY_NIL) != 0)
            {
                _yyerror("Nullable flag '?' for arguments & return type only.");
                // Erase the nullable flag
                $1.var_attrib &= ~AST_VAR_MAY_NIL;
            }

            // For reference value, set MAY_NULL as default
            if ($1.basic_var_type >= REFERENCE_VALUE)
                $1.var_attrib |= AST_VAR_MAY_NIL;

            auto* node = NEW_AST_NODE(AstDeclarations);
            node->var_type = $1;
            node->decl_list = $2;

            auto* decl = node->decl_list;
            while (decl)
            {
                decl->var_type = $1;
                decl = (AstDeclaration*)decl->sibling;
            }

            $$ = node;
        }
    ;

declare_vars:
        declare_1_var
        {
            $$ = $1;
        }
    |
        declare_1_var ',' declare_vars
        {
            $$ = (AstDeclaration*)append_sibling_node($1, $3);
        }
    ;

declare_1_var:
        identifier optional_assign
        {
            auto* decl = NEW_AST_NODE(AstDeclaration);

            decl->name = $1;
            if ($2 != 0)
                decl->expr = $2;

            $$ = decl;
        }
    ;

single_declaration:
        declarations
        {
            auto* decls = (AstDeclarations*)$1;
            if (decls != 0 && decls->decl_list)
            {
                if (decls->decl_list->get_sibling_count() != 0)
                    _yyerror("Expected only 1 variable declaration.");
            }
            $$ = $1;
        }
    ;

optional_assign:
        // empty
        {
            $$ = 0;
        }
    |
        L_ASSIGN expr0
        {
            if ($1 != OP_ASSIGN)
                _yyerror("SyntaxVariable initialization operator can be only '='.");
            $$ = $2;
        }
    ;

goto:
        L_GOTO identifier ';'
        {
            auto* node = NEW_AST_NODE(AstGoto);
            node->goto_type = AST_DIRECT_JMP;
            node->target_label = $2;
            $$ = node;
        }
    ;

if:
        L_IF '(' single_value ')' statement optional_else_part
        {
            // Record else line
            auto* node = NEW_AST_NODE(AstIfElse);
            node->cond = $3;
            node->statement_then = $5;
            node->statement_else = $6;
            $$ = node;
        }
    ;

optional_else_part:
        // empty
        %prec LOWER_THAN_ELSE
        {
            $$ = 0;
	    }
    |   L_ELSE statement
        {
            $$ = $2;
        }
    ;

do:
        L_DO
        {
            auto* node = NEW_AST_NODE(AstDoWhile);
            $<int_val>1 = lang_context->push_loop_switch(node);
        }
        statement L_WHILE '(' single_value ')' ';'
        {
            auto* node = (AstDoWhile*)lang_context->get_loop_switch($<int_val>1);
            STD_ASSERT(("Bad loop_switch node.", node->get_node_type() == AST_DO_WHILE));
            node->statement = $3;
            node->cond = $6;
            SET_NULL_TO_NOP(node->statement);
            $$ = node;
            lang_context->pop_loop_switch($<int_val>1);
        }
    ;

while:
        L_WHILE 
        {
            auto* node = NEW_AST_NODE(AstWhileLoop);
            $<int_val>1 = lang_context->push_loop_switch(node);
        }
        '(' single_value ')' statement
        {
            auto* node = (AstWhileLoop*)lang_context->get_loop_switch($<int_val>1);
            STD_ASSERT(("Bad loop_switch node.", node->get_node_type() == AST_WHILE));
            node->cond = $4;
            node->statement = $6;
            SET_NULL_TO_NOP(node->statement);
            lang_context->pop_loop_switch($<int_val>1);
            $$ = node;
        }

for:
        L_FOR '(' for_init ';' for_cond ';' for_step ')' 
        {
            auto* node = NEW_AST_NODE(AstForLoop);
            $<int_val>1 = lang_context->push_loop_switch(node);
        }
        statement
        {
            auto* node = (AstForLoop*)lang_context->get_loop_switch($<int_val>1);
            STD_ASSERT(("Bad loop_switch node.", node->get_node_type() == AST_FOR));
            node->init = $3;
            node->cond = $5;
            node->step = $7;
            node->statement = $10;
            SET_NULL_TO_NOP(node->statement);
            lang_context->pop_loop_switch($<int_val>1);
            $$ = node;
        }
    |
        L_FOR '(' error ')'
        {
            _yyerror("Bad for expression/condition syntax");
        }
        statement
		{
			$$ = 0;
		}
    ;

for_init:
        // empty
        {
            $$ = 0;
        }
    |
        single_value
        {
            $$ = $1;
        }
    |
        declarations
        {
            $$ = $1;
        }
    ;

for_cond:
        // empty
        {
            $$ = 0;
        }
    |
        single_value
        {
            $$ = $1;
        }
    ;

for_step:
        // empty
        {
            $$ = 0;
        }
    |
        single_value
        {
            $$ = $1;
        }
    ;

loop:
		L_LOOP '(' loop_init ')'
		{
            auto* node = NEW_AST_NODE(AstLoop);
            node->init = $3;
            $<int_val>1 = lang_context->push_loop_switch(node);
		}
		statement
		{
            auto* node = (AstLoop*)lang_context->get_loop_switch($<int_val>1);
            STD_ASSERT(("Bad loop_switch node.", node->get_node_type() == AST_LOOP));
            node->step_cond = NEW_NOP(); // Set nop to the stub node
            node->statement = $6;
            SET_NULL_TO_NOP(node->statement);
            $$ = node;
            lang_context->pop_loop_switch($<int_val>1);
		}
	;

loop_init:
		expr_variable L_ASSIGN single_value to single_value
		{
            auto* node = NEW_AST_NODE(AstLoopInitRange);
            node->decl_or_variable = $1;
            node->begin = $3;
            node->to = $5;
            node->direction = (int)$4;
            $$ = node;
		}
	|
		single_declaration to single_value
		{
            // Check the initialization of variable
            auto* decls = (AstDeclarations*)$1;
            if (decls)
            {
                auto* decl = decls->decl_list;
                if (decl && !decl->expr)
                    _yyerror("Missed initialization for new declaration in loop.\n");
            }

            auto* node = NEW_AST_NODE(AstLoopInitRange);
            node->decl_or_variable = $1;
            node->begin = 0;
            node->to = $3;
            node->direction = (int)$2;
            $$ = node;
		}
	|
		expr_variable L_IN single_value
		{
            auto* node = NEW_AST_NODE(AstLoopInitEach);
            node->decl_or_variable = $1;
            node->container = $3;
            $$ = node;
		}
	|
		single_declaration L_IN single_value
		{
            auto* node = NEW_AST_NODE(AstLoopInitEach);
            node->decl_or_variable = $1;
            node->container = $3;
            $$ = node;
		}
	;

to:
		L_UPTO
		{
            $$ = 1;
		}
	|
		L_DOWNTO
		{
            $$ = -1;
		}
	;

switch:
        L_SWITCH '(' single_value ')'
        {
            auto* node = NEW_AST_NODE(AstSwitchCase);
            $<int_val>1 = lang_context->push_loop_switch(node);
        }
        '{' switch_block '}'
        {
            auto* node = (AstSwitchCase*)lang_context->get_loop_switch($<int_val>1);
            STD_ASSERT(("Bad loop_switch node.", node->get_node_type() == AST_SWITCH_CASE));
            node->expr = $3;
            node->cases = $7;
            lang_context->pop_loop_switch($<int_val>1);
            $$ = node;
            if (!node->cases)
                _yywarn("Missed case for switch.");
        }
    |
        L_SWITCH '(' error ')'
        {
            _yyerror("Bad parameter for switch.");
        }
        '{' switch_block '}'
        {
            $$ = 0;
        }
    ;

switch_block:
        switch_block1
        {
            $$ = $1;
        }
    |
        statement switch_block1
        {
            _yyerror("Invalid statement in the switch block.");
            $$ = $2;
        }
    ;

switch_block1:
        // empty
        {
            $$ = 0;
        }
    |
        switch_block1 case
        {
            $$ = (AstCase*)append_sibling_node($1, $2);
        }
    ;

case:
        L_CASE case_label ':' statements
        {
            auto *node = NEW_AST_NODE(AstCase);
            node->case_value = $2;
            node->statement = $4;
            $$ = node;
        }
    |
        L_CASE error ':'
        {
            _yyerror("Invalid case label: must be constant number or string.");
        }
        statements
        {
            $$ = 0;
        }
    |
        L_DEFAULT ':' statements
        {
            auto *node = NEW_AST_NODE(AstCase);
            node->case_value = 0;
            node->is_default = true;
            node->statement = $3;
            $$ = node;
        }
    |
        L_DEFAULT error ':'
        {
            _yyerror("Invalid parameter for default routine.");
        }
        statements
        {
            $$ = 0;
        }
    ;

case_label:
        constant
        {
            $$ = $1;
        }
    ;

trace:
		L_TRACE '(' comma_expression ')' ';'
		{
#ifdef _DEBUG
            // More to be added
#else
			// For release version, ignore trace action
			$$ = 0;
#endif
		}
	|
		L_TRACE '(' ')' ';'
		{
			$$ = 0;
		}
	;

shout:
		L_SHOUT '(' comma_expression ')' ';'
		{
            // More to be added
		}
	|
		L_SHOUT '(' ')' ';'
		{
			$$ = 0;
		}
	;

constant:
        expr0
        {
            $$ = $1;
            if (!$$->is_constant)
                _yyerror("Bad expression, expected constant.");
        }
    ;

catch:
        L_CATCH '(' single_value ')'
        {
            // More to be added
        }
	|
        L_CATCH block
        {
            // More to be added
        }
    ;

command:
        '\'' comma_expression ';'
        {
            // More to be added
        }
    |
        '\'' ';'
        {
            // More to be added
        }
    ;

single_value:
        comma_expression
        {
            auto* node = NEW_AST_NODE(AstExprSingleValue);
            node->expr_list = $1;
            $$ = node;
        }
    ;

comma_expression:
        expr0
        {
            $$ = $1;
        }
    |
        comma_expression ',' expr0
        {
            $$ = (AstExpr*)append_sibling_node($1, $3);
        }
    ;

expr0:
        L_INC element
        {
            auto* node = NEW_AST_NODE(AstExprUnary);
            node->op = OP_INC_PRE;
            node->expr1 = $2;
            $$ = node;
        }
    |
        L_DEC element
        {
            auto* node = NEW_AST_NODE(AstExprUnary);
            node->op = OP_DEC_PRE;
            node->expr1 = $2;
            $$ = node;
        }
    |
        element L_INC
        {
            auto* node = NEW_AST_NODE(AstExprUnary);
            node->op = OP_INC_POST;
            node->expr1 = $1;
            $$ = node;
        }
    |
        element L_DEC
        {
            auto* node = NEW_AST_NODE(AstExprUnary);
            node->op = OP_DEC_POST;
            node->expr1 = $1;
            $$ = node;
        }
    |
        element L_ASSIGN expr0
        {
            auto* expr_assign = NEW_AST_NODE(AstExprAssign);
            expr_assign->op = $2;
            expr_assign->expr1 = $1;
            expr_assign->expr2 = $3;
            $$ = expr_assign;
        }
    |
        expr0 L_LAND expr0
        {
            auto* node = NEW_AST_NODE(AstExprBinary);
            node->op = OP_LAND;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |
        expr0 L_LOR expr0
        {
            auto* node = NEW_AST_NODE(AstExprBinary);
            node->op = OP_LOR;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |
        expr0 L_OR expr0
        {
            auto* node = NEW_AST_NODE(AstExprBinary);
            node->op = OP_OR;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_XOR expr0
        {
            auto* node = NEW_AST_NODE(AstExprBinary);
            node->op = OP_XOR;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_AND expr0
        {
            auto* node = NEW_AST_NODE(AstExprBinary);
            node->op = OP_AND;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_EQ expr0
        {
            auto* node = NEW_AST_NODE(AstExprBinary);
            node->op = OP_EQ;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_NE expr0
        {
            auto* node = NEW_AST_NODE(AstExprBinary);
            node->op = OP_NE;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_ORDER expr0
        {
            auto* node = NEW_AST_NODE(AstExprBinary);
            node->op = $2;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_LT expr0
        {
            auto* node = NEW_AST_NODE(AstExprBinary);
            node->op = OP_LT;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_LSH expr0
        {
            auto* node = NEW_AST_NODE(AstExprBinary);
            node->op = OP_LSH;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_RSH expr0
        {
            auto* node = NEW_AST_NODE(AstExprBinary);
            node->op = OP_RSH;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 '?' expr0 ':' expr0 %prec '?'
        {
            auto* node = NEW_AST_NODE(AstExprTernary);
            node->op = OP_QMARK;
            node->expr1 = $1;
            node->expr2 = $3;
            node->expr3 = $5;
            $$ = node;
        }
    |   expr0 L_ADD expr0
        {
            auto* node = NEW_AST_NODE(AstExprBinary);
            node->op = OP_ADD;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_SUB expr0
        {
            auto* node = NEW_AST_NODE(AstExprBinary);
            node->op = OP_SUB;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_MUL expr0
        {
            auto* node = NEW_AST_NODE(AstExprBinary);
            node->op = OP_MUL;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_MOD expr0
        {
            auto* node = NEW_AST_NODE(AstExprBinary);
            node->op = OP_MOD;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_DIV expr0
        {
            auto* node = NEW_AST_NODE(AstExprBinary);
            node->op = OP_DIV;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |
        L_SUB expr0 %prec L_NOT
        {
            auto* node = NEW_AST_NODE(AstExprUnary);
            node->op = OP_NEG;
            node->expr1 = $2;
            $$ = node;
        }
    |
        L_NOT expr0
        {
            auto* node = NEW_AST_NODE(AstExprUnary);
            node->op = OP_NOT;
            node->expr1 = $2;
            $$ = node;
        }
    |
        L_REV expr0
        {
            auto* node = NEW_AST_NODE(AstExprUnary);
            node->op = OP_REV;
            node->expr1 = $2;
            $$ = node;
        }
    |
        cast expr0 %prec L_NOT
        {
            auto* node = NEW_AST_NODE(AstExprCast);
            node->op = OP_CAST;
            node->var_type = $1;
            node->expr1 = $2;
            $$ = node;
        }
    |
        element
        {
            $$ = $1;
        }
    ;

element:
        L_NIL
        {
            auto* node = NEW_AST_NODE(AstExprConstant);
            node->value = MMMValue();
            $$ = node;
        }
    |
        L_REAL
        {
            auto* node = NEW_AST_NODE(AstExprConstant);
            node->value = MMMValue($1);
            $$ = node;
        }
    |
        L_NUMBER
        {
            auto* node = NEW_AST_NODE(AstExprConstant);
            node->value = MMMValue($1);
            $$ = node;
        }
    |
        strings
        {
            auto* node = NEW_AST_NODE(AstExprConstant);
            node->value = MMMValue(STRING_ALLOC($1));
            $$ = node;
        }
    |
        L_FUNCTION_OPEN identifier possible_arguments ':' ')'
        {
            auto* node = NEW_AST_NODE(AstExprCreateFunction);
            node->name = $2;
            node->expr_list = $3;
            $$ = node;
        }
    |
        L_ARRAY_OPEN comma_expression possible_comma '}' ')'
        {
            auto* node = NEW_AST_NODE(AstExprCreateArray);
            node->expr_list = $2;
            $$ = node;
        }
    |
        L_ARRAY_OPEN possible_comma '}' ')'
        {
            auto* node = NEW_AST_NODE(AstExprCreateArray);
            node->expr_list = 0;
            $$ = node;
        }
    |
        L_MAPPING_OPEN mapping_pairs ']' ')'
        {
            auto* node = NEW_AST_NODE(AstExprCreateMapping);
            node->expr_list = $2;
            $$ = node;
        }
    |
        expr_variable
        {
            $$ = $1;
        }
    |
       '(' single_value ')'
        {
            $$ = $2;
        }
    |
        L_CALL '(' ')'
        {
            _yyerror("Missed function to call.");
            $$ = 0;
        }
    |
        L_CALL '(' comma_expression ')'
        {
            auto* node = NEW_AST_NODE(AstExprFunctionCallEx);
            node->arguments = $3;
            $$ = node;
        }
    |
        fun_call
        {
            $$ = $1;
        }
    |
        element '.' identifier
        {
            auto* node = NEW_AST_NODE(AstExprSegment);
            node->expr = $1;
            node->name = $3;
            $$ = node;
        }
    |
        element '[' single_value ']'
        {
            auto* node = NEW_AST_NODE(AstExprIndex);
            node->container = $1;
            node->index_from = $3;
            node->op = OP_IDX;
            $$ = node;
        }
    |
        element '[' L_LT single_value ']'
        {
            auto* node = NEW_AST_NODE(AstExprIndex);
            node->container = $1;
            node->index_from = $4;
            node->op = OP_IDX;
            node->is_reverse_from = true;
            $$ = node;
        }
    |
        element '[' single_value L_RANGE single_value ']'
        {
            auto* node = NEW_AST_NODE(AstExprIndex);
            node->container = $1;
            node->index_from = $3;
            node->index_to = $5;
            node->op = OP_IDX_RANGE;
            $$ = node;
        }
    |
        element '[' single_value L_RANGE L_LT single_value ']'
        {
            auto* node = NEW_AST_NODE(AstExprIndex);
            node->container = $1;
            node->index_from = $3;
            node->index_to = $6;
            node->is_reverse_to = true;
            node->op = OP_IDX_RANGE;
            $$ = node;
        }
    |
        element '[' L_LT single_value L_RANGE L_LT single_value ']'
        {
            auto* node = NEW_AST_NODE(AstExprIndex);
            node->container = $1;
            node->index_from = $4;
            node->index_to = $7;
            node->is_reverse_from = true;
            node->is_reverse_to = true;
            node->op = OP_IDX_RANGE;
            $$ = node;
        }
    |
        '$' L_NUMBER
        {
            auto* expr = NEW_AST_NODE(AstExprConstant);
            expr->value = MMMValue($2);
            auto* node = NEW_AST_NODE(AstExprUnary);
            node->expr1 = expr;
            node->op = OP_DOLLAR;
            $$ = node;
        }
    |
        '$' '(' single_value ')'
        {
            auto* node = NEW_AST_NODE(AstExprUnary);
            node->expr1 = $3;
            node->op = OP_DOLLAR;
            $$ = node;
        }
	|
		'$' '<'
		{
            auto* node = NEW_AST_NODE(AstExprRuntimeValue);
            node->var_type.basic_var_type = ARRAY;
            node->value_id = AST_RV_INPUT_ARGUMENTS;
            $$ = node;
		}
    |
        '$' '?'
        {
            auto* node = NEW_AST_NODE(AstExprRuntimeValue);
            node->var_type.basic_var_type = INTEGER;
            node->value_id = AST_RV_INPUT_ARGUMENTS_COUNT;
            $$ = node;
        }
    |
        L_AND element
        {
            auto* node = NEW_AST_NODE(AstExprUnary);
            node->expr1 = $2;
            node->op = OP_AND;
            $$ = node;

            ////****
            // There is a problem: If user put a non-valid type value in
            // refered value, it may cause crash
            // More to be added
            ////----
        }
    |
        L_IS_REF '(' identifier ')'
        {
            auto* node = NEW_AST_NODE(AstExprIsRef);
            node->name = $3;
            $$ = node;
        }
    |
        catch
        {
            $$ = $1;
        }
    |
        '(' arguments_ex ')' // closure
        {
            auto* prototype = NEW_AST_NODE(AstPrototype);
            prototype->ret_var_type.basic_var_type = MIXED;
            prototype->ret_var_type.var_attrib = (AstVarAttrib)0;
            prototype->attrib = AST_RANDOM_ARG | AST_ANONYMOUS_CLOSURE;
            prototype->name = "";
            prototype->arg_list = $2.arg_list;
            if ($2.ddd)
                prototype->attrib = prototype->attrib | AST_RANDOM_ARG;

            auto* function = NEW_AST_NODE(AstFunction);
            function->prototype = prototype;
            function->no = (FunctionNo)lang_context->m_functions.size();
            lang_context->m_functions.push_back(function);

            auto* prev = lang_context->m_in_function;
            lang_context->m_in_function = function;
            $<function>1 = prev;
        }
        '{' statements '}'
        {
            auto* function = lang_context->m_in_function;
            function->body = $6;

            // Restore previous function
            lang_context->m_in_function = $<function>1;

            auto* node = NEW_AST_NODE(AstExprClosure);
            node->function = function;
            $$ = node;
        }
    ;

expr_variable:
        identifier
        {
            auto* node = NEW_AST_NODE(AstExprVariable);
            node->name = $1;
            $$ = node;
        }
    ;

possible_arguments:
        // empty
        {
            $$ = 0;
        }
    |
        ',' comma_expression
        {
            $$ = $2;
        }
    ;

fun_call:
        '(' L_MUL element ')' '(' ')'
        {
            auto* node = NEW_AST_NODE(AstExprFunctionCallEx);
            node->arguments = $3;
            $$ = node;
        }
    |
        '(' L_MUL element ')' '(' comma_expression ')'
        {
            auto* node = NEW_AST_NODE(AstExprFunctionCallEx);
            node->arguments = (AstExpr*)append_sibling_node($3, $6);
            $$ = node;
        }
    |
        identifier '(' ')'
        {
            auto* node = NEW_AST_NODE(AstExprFunctionCall);
            node->target = 0;
            node->callee_name = $1;
            node->arguments = 0;
            $$ = node;
        }
    |
        identifier '(' comma_expression ')'
        {
            auto* node = NEW_AST_NODE(AstExprFunctionCall);
            node->target = 0;
            node->callee_name = $1;
            node->arguments = $3;
            $$ = node;
        }
    |
        element L_ARROW identifier '(' ')'
        {
            auto* node = NEW_AST_NODE(AstExprFunctionCall);
            node->target = $1;
            node->callee_name = $3;
            node->arguments = NULL;
            $$ = node;
        }
    |
        element L_ARROW identifier '(' comma_expression ')'
        {
            auto* node = NEW_AST_NODE(AstExprFunctionCall);
            node->target = $1;
            node->callee_name = $3;
            node->arguments = $5;
            $$ = node;
        }
    ;

mapping_pairs:
        // empty
        {
            $$ = 0;
        }
    |
        mapping_pair
        {
            $$ = $1;
        }
    |
        mapping_pair ',' mapping_pairs
        {
            $$ = (AstExpr*)append_sibling_node($1, $3);
        }
    ;

mapping_pair:
        expr0 ':' expr0
        {
            $$ = (AstExpr*)append_sibling_node($1, $3);
        }
    ;

possible_comma:
        // empty
    |
        ','
    ;

cast:
        '(' var_type ')'
        {
            if ($2.basic_var_type == TVOID || $2.basic_var_type == NIL)
                _yyerror("Invalid type to cast.");

            $$ = $2;
        }
    ;

strings:
        L_STRING
        {
            $$ = $1
        }
    |
        L_STRING strings
        {
            size_t len1 = strlen($1);
            size_t len2 = strlen($2);
            auto* c_str = LANG_NEWN(lang_context, char, len1 + len2 + 1);
            memcpy(c_str, $1, len1);
            memcpy(c_str + len1, $2, len2 + 1);
            $$ = c_str;
        }
    ;

identifier:
        L_IDENTIFIER
        {
            $$ = $1;
        }
     ;
%%

} // End of namespace: cmm
