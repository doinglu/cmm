// cmm_grammar.y:
// Initial version 2001.12.12 by doing
// Updated 2011.6.30 by shenyq
// Immigrated 2015.10.29 by doing

%parse-param {LangContext *context}
%lex-param {void}

%{
/* Don't be worried about the possible warnings.
 * This file is generated by YACC. */

#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#include "cmm.h"
#include "cmm_buffer_new.h"
#include "cmm_const.h"
#include "cmm_efun.h"
#include "cmm_program.h"
#include "cmm_common_util.h"
#include "cmm_lang.h"
#include "cmm_lexer.h"
#include "cmm_register_allocator.h"

namespace cmm
{

#define isalunum(c) (isalnum(c) || (c) == '_')

#define MAX_COMPILER_ERRORS     64
#define YYDEBUG 0

#define malloc          vm_scratchAlloc
#define free            vm_scratchFree

#define yyerror         syntax_error
#define yyerrors        syntax_errors
#define yywarn          syntax_warn
#define yywarns         syntax_warns

#define _yyerror(str)   syntax_error(context, str)
#define _yyerrors(...)  syntax_errors(context, __VA_ARGS__)
#define _yywarn(str)    syntax_warn(context, str)
#define _yywarns(...)   syntax_warns(context, __VA_ARGS__)
#define _yystop()       syntax_stop(context, VM_COMPILE_ERROR)

/* Define the "yyparse" as a macro in case of name conflict with other
 * files generated by YACC */
#define yyparse         lang_parse
#define yylex           context->lex_in

#define _APPEND_SRC(...) do { \
        if (STRLEN(buffer) > VM_GLOBAL_BUF_SIZE - 256) { \
            _yyerrors("Source is too long."); \
        } else \
        SNPRINTF(buffer + strlen(buffer), VM_GLOBAL_BUF_SIZE - strlen(buffer), __VA_ARGS__); \
    } while (0)

/* Internal routines */
static void cmm_destroy_expressions(LangContext* context, AstExpressions* exps);
static void cmm_lang_parse(LangContext* context);

%}

/*
 * Token definitions.
 *
 * Appearing in the precedence declarations are:
 *      '+'  '-'  '/'  '*'  '%'
 *      '&'  '|'  '<'  '>'  '^'
 *      '~'  '?'
 *
 * Other single character tokens recognized in this grammar:
 *      '{'  '}'  ','  ';'  ':'
 *      '('  ')'  '['  ']'  '$'
 */

%token L_STRING L_NUMBER L_REAL
%token L_BASIC_TYPE
%token L_DEFINED_NAME L_IDENTIFIER L_EFUN L_FUN L_OSFUN L_OSVAR
%token L_LABEL
%token L_NIL
%token L_IS_REF

%token L_ADD_COMPONENT
%token L_USING L_USING_STATEMENT

%token L_INC L_DEC
%token L_ASSIGN
%token L_LAND L_LOR
%token L_LSH L_RSH
%token L_ORDER
%token L_NOT

%token L_BUILD
%token L_IF L_ELSE
%token L_SWITCH L_CASE L_DEFAULT L_RANGE L_DOT_DOT_DOT
%token L_WHILE L_DO L_FOR
%token L_LOOP L_UPTO L_DOWNTO L_EACH L_IN
%token L_BREAK L_CONTINUE
%token L_ARROW L_EXPAND_ARROW L_COLON_COLON
%token L_ARRAY_OPEN L_MAPPING_OPEN L_FUNCTION_OPEN
%token L_GOTO
%token L_CALL
%token L_RETURN
%token L_TRACE L_SHOUT
%token L_GLOBAL

%token L_TRY L_CATCH

%token L_PRIVATE L_PUBLIC
%token L_OVERRIDE L_NOMASK
%token L_VARARGS
%token L_STATIC
%token L_NOSAVE
%token L_CONST
%token L_FILE

%union
{
    Integer             number;
    Real                real;
    StringImpl         *string;
    ValueType           basic_type;
    AstVarType          type;
    AstVariableInfo     variable;
    AstFunction*        fun;
    AstFunctionArg*     argument;
    AstFunctionArgs*    arg_list;
    AstElement*         element;
    AstCase*            switch_case;
    AstFunctionDesc     function_desc;
    AstVariableDesc     var_desc;
    AstLValueInfo*      lv_info;
    AstExpression*      expression;
    AstExpressions*     expressions;
    SyntaxSourceNode*   source_node;
    AstDeclare*         declares;
    SyntaxMappingPair*  mapping_pair;
    Vector_T            array;
    SyntaxContextState  context_state;
}

/*
 * 'Dangling else' shift/reduce conflict is well known...
 *  define these precedences to shut yacc up.
 */

%nonassoc LOWER_THAN_ELSE
%nonassoc L_ELSE

/*
 * Operator precedence and associativity...
 * greatly simplify the grammar.
 */

%right L_ASSIGN
%right '?'
%right ':'
%left L_LOR
%left L_LAND
%left '|'
%left '^'
%left '&'
%left L_EQ L_NE
%left L_ORDER '<'
%left L_LSH L_RSH
%left '+' '-'
%left '*' '%' '/'
%right L_NOT '~'
%nonassoc L_INC L_DEC
/*
 * Type declarations.
 */

/* These hold opcodes */
%type <number>      L_ASSIGN L_ORDER

/* These hold arbitrary numbers */
%type <number>      L_NUMBER constant case_label
%type <basic_type>  optional_undefined optional_and

/* These hold a signal number (-1/+1) */
%type <number>      to

/* These hold a real number */
%type <real>        L_REAL

/* holds a string constant */
%type <string>      L_STRING strings

/* These hold a list of possible interpretations of an identifier */
%type <string>      L_LABEL

/* Threse hold variable description */
%type <var_desc>    L_DEFINED_NAME variable variable_value

/* These hold a type */
%type <type>        cast var_type

/* These hod a basic type */
%type <basic_type>  L_BASIC_TYPE var_attrib

/* These hold a function type */
%type <number>      fun_attrib  fun_type

/* These hold a string */
%type <string>      L_IDENTIFIER identifier identifier_to_be_finalized

/* These hold a string */
%type <string>      L_USING_STATEMENT

/* These hold a function call */
%type <function_desc>     L_EFUN
%type <function_desc>     L_FUN

%type <string>      L_FILE

/* These hold a declaration of variable(s) */
%type <declares> declare_vars declare_1_var 

%type <source_node> declaration 

/* These hold a serial of actions */
%type <AstStatement*>  statement statements
%type <string>         add_component using block label
%type <source_node>    try_catch 
%type <source_node>    if for loop optional_else_part
%type <source_node>    do while goto switch
%type <array>          value_ptr_or_new_id_with_optional_assign loop_init
%type <source_node>    trace shout
%type <source_node>    command
%type <mapping_pair>   mapping_pairs mapping_pair
%type <lv_info>        assignable_ptr value_ptr_or_new_id value_ptr
%type <fun>            function prototype raw_prototype
%type <function_desc>  efun_or_fun may_fun
%type <arg_list>       arg_list new_arg
%type <argument>       argument
%type <switch_case>    switch_block switch_block1 case
%type <expression>     expr0 expression optional_assign 
%type <expressions>    comma_expression possible_arguments
%type <element>        element may_array_or_expr fun_call single_value for_expr for_cond catch may_object

%%

all:
        {            
        }
        statements
        {
            // 仅当没有错误的时候进行后续处理
            if (context->m_num_errors == 0)
            {
            }
            else
            {
                vm_printf("Total %d errors %d warning.\n", context->m_num_errors, context->numWarnings);
            }
        }
    ;

statements:
        /* empty */
        {
            $$ = NULL;
        }
    |
        statement
        {
            if (context->m_in_function == NULL)
            {
                cmm_free_ret_registers(context->m_entry_function);
            }
            else
            {
                cmm_free_ret_registers(context->m_in_function);
            }
        }
        statements
        {
            $$ = $1;
            list_append(&$$, $3);
        }
    |
        add_component statements
        {
            context->syntax_add_component($1);
            $$ = $2;
        }
    |
		using statements
		{
		}
    |
        function statements
        {
            if ($1)
                context->syntax_add_member_function($1);

            $$ = $2;
        }
    |
        declaration 
        {
            // 回收寄存器
            if (context->m_in_function == NULL)
            {
                cmm_free_ret_registers(context->m_entry_function);
            }
            else
            {
                cmm_free_ret_registers(context->m_in_function);
            }
        }
        statements
        {
            if (context->m_in_function == NULL && !context->context_state.is_in_block)
            {
                // 当前在外部
                $$ = $1;
                list_append(&$$, $3);
            }
            else
            {
                // 当前在函数内部
                $$ = $1;
                list_append(&$$, $3);
            }
        }
    |
        error
        {
            $$ = NULL;
        }
    ;

block:
	    '{' 
        {
            $<number>1 = context->context_state.is_in_block;
            context->context_state.is_in_block = true;
        }
        statements '}'
        {
            $$ = $3;

            context->context_state.is_in_block = $<number>1;
        }
    ;

try_catch:
        /* newCatch   $2   endCatch   pGoto     $4
         *     |                        |        |       |
         *     |                        +------->>-------+
         *     |                                 |
         *     +------------->>------------------+
         */
		L_TRY 
        {
            $<number>1 = context->context_state.is_in_block;
            context->context_state.is_in_block = true;
        }
        block L_CATCH block
		{
            //$$ = vm_genTryCatchSource(context, $3, $5);
            context->context_state.is_in_block = $<number>1;
		}
	;

label:  identifier ':'
        {
            char src[1024];
            SNPRINTF(src, 1024, "%s:\n", $1);
            //$$ = vm_newSourceNode(src);
        }
    ;

statement:
        error ';'
        {
            _yyerror("Illegal statement.");
            $$ = NULL;
        }
    |
        ';'
        {
            $$ = NULL;
        }
    |
        single_value ';'
        {
            $$ = vm_newSourceNode($1->source);
            $$ = vm_insertLineNode(context, $$);
        }
    |   label
    |   block
    |   if
    |   for
	|   loop
    |   do
    |   while
	|	try_catch
    |   switch
    |   goto
	|   trace
    |   shout
    |
        L_BREAK ';'
        {
            if (context->context_state.contextType == VM_CONTEXT_MAIN && ! context->context_state.inSwitch)
            {
                _yyerror("Break mismatched loop or switch.");
                $$ = NULL;
            }
            else
            {
                char jmpstr[128];
                SPRINTF(jmpstr, "jmp label_break_%d;\n",
                        (int) context->context_state.breakId);
                $$ = vm_newSourceNode(jmpstr);
                $$ = vm_insertLineNode(context, $$);
            }
        }
    |
        L_CONTINUE ';'
        {
            char jmpstr[128];
            
            if (context->context_state.contextType == VM_CONTEXT_FOR || context->context_state.contextType == VM_CONTEXT_LOOP) 
            {
                SPRINTF(jmpstr, "jmp label_continue_%d;\n", (int) context->context_state.continueId);
                $$ = vm_newSourceNode(jmpstr);
            }
            else if (VM_CONTEXT_WHILE)
            {
                SPRINTF(jmpstr, "jmp label_test_block_%d;\n", (int) context->context_state.continueId);
                $$ = vm_newSourceNode(jmpstr);
            }
            else
            {
                _yyerror("Continue mismatched loop or switch.");
                $$ = NULL;
            }

            if ($$)
                $$ = vm_insertLineNode(context, $$);
        }
    |
        L_RETURN ';'
        {
            if (context->m_in_function)
                $$ = vm_newSourceNode("ret_v;\n");
            else
                $$ = vm_newSourceNode("retg_v;\n");

            $$ = vm_insertLineNode(context, $$);
        }
    |
        L_RETURN 
        {
            $<source_node>$ = vm_insertLineNode(context, NULL);
        }
        single_value ';'
        {
            char *src = vm_getGlobalBuf(VM_GLOBAL_BUF_SIZE, __FUNCTION__);
            char *output = $3->output;
            SyntaxSourceNode *res = $<source_node>2;

            src[0] = 0;

            if ($3->source)
                res = vm_mergeSourceNode(res, vm_newSourceNode($3->source));

            VM_ASSERT(output);

            if (context->m_in_function)
                SPRINTF(src, "ret_%c %s;\n", vm_getTypeChar($3->type), output);
            else
                SPRINTF(src, "retg_%c %s;\n", vm_getTypeChar($3->type), output);

            $$ = vm_mergeSourceNode(res, vm_newSourceNode(src));
            
            vm_releaseGlobalBuf(src, __FUNCTION__);

            /* change the entry function type */
            if (! context->m_in_function)
                context->m_entry_function->retVarType.basicType = VM_TYPE_MIXED;
        }
    |
        command
        {
            $$ = $1;
        }
    |   
        L_FILE
        {
            char file[256];
            SNPRINTF(file, 256, "@file_s \"%s\";\n", $1);
            $$ = vm_newSourceNode(file);
        }
    ;

add_component:
        L_ADD_COMPONENT strings ';' 
        {
            const static size_t MAX_INHERIT_SIZE = 256;
            char buf[1024];

            if (strlen($2) > MAX_INHERIT_SIZE)
            {
                _yyerror("Inherit name is too long.");
                $$ = NULL;
            }
            else
            {
                syntax_add_component(context, $2);          
                SPRINTF(buf, "add \"%s\";\n", $2);
                vm_scratchFree($2);
                $$ = vm_newSourceNode(buf);
            }
        }
    ;

using:
		L_USING_STATEMENT ';'
		{
            _yyerror("Using statement is deprecated.");
            $$ = NULL;
		}

function:
        prototype 
        {
            context->m_in_function = $1;

            // 添加到context中
            context->syntax_add_member_function($1);
        }
        '{' statements '}'
        {
            // 函数体
            if ($4)
                $1->bodyNode = $4;
            else
                $1->bodyNode = vm_newSourceNode("");

            // 恢复为空
            context->m_in_function = NULL;
            
            $$ = $1;
        }
    |
        prototype ';'
        {
            AstFunction *func = syntax_get_member_function(context, $1->name);

            $$ = $1;            
            context->syntax_add_member_function($1);
        }
    |
        prototype error
        {
            _yyerror("Function prototype declaration miss ';'.");
            $$ = NULL;
        }
    ;

prototype:
        fun_type raw_prototype
        {
            $2->funAttrib |= $1;
            
            $$ = $2;
        }
    |
        raw_prototype
        {
            $$ = $1;
        }
    ;

fun_type:
        fun_attrib
        {
            $$ = $1;
        }
    |
        fun_type fun_attrib
        {
            $$ = $1 | $2;            

            if ($$ != 0xFFFFFFFF)
            {
                if (($$ & VM_FUN_PRIVATE) && ($$ & VM_FUN_NO_PRIVATE))
                {
                    $$ = 0xFFFFFFFF;
                    _yyerror("private conflict with public.");
                } 
            }
        }
    ;

fun_attrib:
        L_PRIVATE
        {
            $$ = VM_FUN_PRIVATE;
        }
    |
        L_PUBLIC
        {
            $$ = VM_FUN_PUBLIC;
        }
    |
        L_OVERRIDE
        {
            $$ = VM_FUN_OVERRIDE;
        }
    |
        L_VARARGS
        {
            $$ = VM_FUN_RANDOM_ARG;
        }
    |
        L_NOMASK
        {
            $$ = VM_FUN_UNMASKABLE;
        }
    ;

raw_prototype:
        var_type identifier_to_be_finalized
        {
            AstFunction *fun;
        
            // 构造成员方法结构
            fun = context->syntax_create_function($2);

            if (context->m_in_function)
            {
                _yyerror("Can not declare a function inside a function.");
                _yystop();
            }            

            /* consider current attribute */
            if (context->currentAttrib & VM_ATTR_OVERRIDE)
                fun->funAttrib |= VM_FUN_OVERRIDE;

            /* constructor or destructor must be private */
            if (STRCMP($2, "create") == 0 || STRCMP($2, "destroy") == 0)
                fun->funAttrib |= VM_FUN_PRIVATE;

            // 设置当前函数
            context->m_in_function = fun;           
        }
         '(' argument ')'
        {
            AstFunction *fun = context->m_in_function;

            fun->retVarType = $1;
            fun->pArgList = $5;

            $$ = fun; 
            
            context->m_in_function = NULL;
        }
    ;

var_type:
        var_attrib L_BASIC_TYPE optional_undefined
        {
            AstVarType varType;
            varType.basicType = $2;
            varType.varAttrib = ($1 | $3);
            $$ = varType;
        }
    ;

var_attrib:
		/* Empty */
		{
            $$ = 0;
		}
	|
        L_STATIC var_attrib
        {
            if (context->m_in_function != NULL)
                _yywarns("Unused property \"static\" for a local variable.\n");
            else
            if (! context->isGlobal)
                _yywarns("Unused property \"static\" for a object's private variable.\n");
            else
                $$ = VM_VAR_STATIC | $2;
        }
    |
		L_NOSAVE var_attrib
		{
            $$ = VM_VAR_NO_SAVE | $2;
		}
    |
        L_CONST var_attrib
        {
            $$ = VM_VAR_CONST | $2;
        }
	;

argument:
        /* empty */
        {
            $$.pArgs = NULL;
            $$.ddd = 0;
        }
    |
        L_DOT_DOT_DOT
        {
            $$.pArgs = NULL;
            $$.ddd = 1;
        }
    |
        arg_list
        {
            $$.pArgs = $1;
            $$.ddd = 0;
        }
    |
        arg_list L_DOT_DOT_DOT
        {
            $$.pArgs = $1;
            $$.ddd = 1;
        }
    ;

arg_list:
        new_arg
        {
            if ($1 != NULL)
                $1->pNext = NULL;
            
            $$ = $1;
        }
    |
        new_arg ',' arg_list
        {
            if ($1 != NULL)
            {
                /* Check default value */
                if ($1->pDefaultValue != NULL && $3->pDefaultValue == NULL)
                    _yyerror("Bad argument, miss default value.\n");

                $1->pNext = $3;
                $$ = $1;
            } else
                $$ = $3;
        }
    ;

new_arg:
        error
        {
            $$ = NULL;
        }
    |
        var_type optional_and identifier_to_be_finalized optional_assign
        {
            if ($1.basicType == VM_TYPE_VOID || $1.basicType == VM_TYPE_UNDEFINED)
			{
	            $$ = NULL;
                _yyerror("Invalid argument type.");
            } else
            {
                AstFunctionArg *pArg;
                pArg = (AstFunctionArg *) vm_scratchAlloc(sizeof(*pArg));
                pArg->name = vm_scratchCopyCStr($3); /* Free $3 @ end of block */
                $1.varAttrib |= $2;
                pArg->varType = $1;
                pArg->pNext = NULL;

                if ($4)
				    pArg->pDefaultValue = $4; 
			    else
			        pArg->pDefaultValue = NULL;
                $$ = pArg;
            } 
        }
    |
        var_type optional_and optional_assign
        {
            if ($1.basicType == VM_TYPE_VOID || $1.basicType == VM_TYPE_UNDEFINED)
			{
				$$ = NULL;
                _yyerror("Invalid argument type.");
            } else
            {
                AstFunctionArg *pArg;
                pArg = (AstFunctionArg *) vm_scratchAlloc(sizeof(*pArg));
                pArg->name = vm_scratchCopyCStr("");
                $1.varAttrib |= $2;
                pArg->varType = $1;
                pArg->pNext = NULL;
                if ($3)
				    pArg->pDefaultValue = $3;
				else
				    pArg->pDefaultValue = NULL;
                $$ = pArg;
            }
        }
    |
        identifier_to_be_finalized optional_assign
        {
            AstFunctionArg *pArg;
            pArg = (AstFunctionArg *) vm_scratchAlloc(sizeof(*pArg));
            pArg->name = vm_scratchCopyCStr($1); /* Free $1 @ end of block */
            pArg->varType.basicType = VM_TYPE_MIXED;
            pArg->varType.varAttrib = 0;
            pArg->pNext = NULL;
            if ($2)
                pArg->pDefaultValue = $2;
            else
                pArg->pDefaultValue = NULL;
            $$ = pArg;

            vm_scratchFree($1);
        }
    |
        identifier identifier_to_be_finalized optional_assign
        {
            AstFunctionArg *pArg;

            _yyerror("Invalid argument type.");
            pArg = (AstFunctionArg *) vm_scratchAlloc(sizeof(*pArg));
            pArg->name = vm_scratchCopyCStr($2); /* Free $2 @ end of block */
            pArg->varType.basicType = VM_TYPE_MIXED;
            pArg->varType.varAttrib = 0;
            pArg->pNext = NULL;
            if ($3)
			    pArg->pDefaultValue = $3;
			else
			    pArg->pDefaultValue = NULL;
            $$ = pArg;

            vm_scratchFree($2);
        }
    ;

optional_and:
        /* empty */
        {
            $$ = 0;
        }
    |
        '&'
        {
            $$ = VM_VAR_REF_ARGUMENT;
        }
    ;

optional_undefined:
        /* empty */
        {
            $$ = 0;
        }
    |
        '?'
        {
            $$ = VM_VAR_MAY_NULL;
        }
    ;

declaration:
        var_type declare_vars ';'
        {
            SyntaxSourceNode *res = NULL;
            AstDeclare *decl = $2;

            if ($1.basicType == VM_TYPE_VOID || $1.basicType == VM_TYPE_UNDEFINED)
                _yyerror("Invalid variable type.");

            // 设置类型
            while (decl)
            {
                decl->type = $1;

                if (decl->pExpr)
                {
                    AstExpression* assignExp = context->syntax_create_expression(NULL);
                    AstElement *elem = context->syntax_create_element();
                    AstLValueInfo *dest = context->syntax_create_lvalue_info();
                    Vm_Exp_Result_T assignRes;

                    if ($1.varAttrib & VM_VAR_MAY_NULL)
                        elem->type = VM_TYPE_MIXED;
                    else
                        elem->type = $1.basicType;

                    elem->isConstant = 0;
                    elem->source = NULL;
                    elem->output = vm_scratchCopyCStr(decl->name);
                
                    dest->pElemValue = elem;

                    assignExp->pLeft = context->syntax_create_expression(NULL);
                    assignExp->pLeft->pLv = dest;
                    assignExp->pRight = decl->pExpr;
                    assignExp->op = F_ASSIGN;
                    
                    assignRes = context->syntax_finalize_expression(assignExp);                    
                    res = vm_mergeSourceNode(res, vm_newSourceNode(assignRes.source));
                }
                
                decl = decl->pNext;
            }

            if (context->m_in_function)
            {
                // 在函数中，是局部变量
                context->syntax_add_local_variable($2);
            }
            else
            {
                // 不在函数中，是成员变量
                context->syntax_add_member_variable($2);
            }

            $$ = vm_insertLineNode(context, res);
        }
    ;

declare_vars:
        declare_1_var
        {
            $$ = $1;
        }
    |
        declare_1_var ',' declare_vars
        {
            $1->pNext = $3;
        }
    ;

declare_1_var:
        identifier_to_be_finalized optional_assign
        {
            AstDeclare *decl = context->syntax_create_declare($1);
            decl->line = context->syntax_get_current_line();

            if ($2 != NULL)
            {
                decl->pExpr = $2;
            }
            $$ = decl;
        }
    ;

optional_assign:
        /* empty */
        {
            $$ = NULL;
        }
    |
        L_ASSIGN expression
        {
            if ($1 != F_ASSIGN)
                _yyerror("SyntaxVariable initialization operator can be only '='.");
            $$ = $2;
        }
    ;

goto:
        L_GOTO identifier ';'
        {
            char src[1024];
            SNPRINTF(src, 1024, "jmp %s;\n", $2);
            $$ = vm_newSourceNode(src);
        }
    ;

if:
        L_IF '(' single_value ')' 
        {
            $<source_node>$ = vm_insertLineNode(context, NULL);
            $<number>1 = context->context_state.is_in_block;
            $<number>2 = context->syntax_get_current_line();
            context->context_state.is_in_block = true;
        }
        statement 
        {
            /* Record else line */
            $<number>4 = context->syntax_get_current_line() + 1;
        }
        optional_else_part
        /* $3   pIf   $5   pGoto   $6     
         *       |           |      |  |
         *       +------------------+  |
         *                   |         |
         *                   +---------+
         *
         * $3   pIf   $5
         *       |        |
         *       +--------+ */
        {
            context->context_state.is_in_block = $<number>1;
            $$ = vm_genIfSource(context, $3, $6, $8, $<number>2, $<number>4, context->syntax_get_current_line());
            $$ = vm_mergeSourceNode($<source_node>5, $$);
        }
    ;

optional_else_part:
        /* empty */    %prec LOWER_THAN_ELSE
        {
            $$ = NULL;
	    }
    |   L_ELSE statement
        {
            $$ = $2;
        }
    ;

do:
        /* $3(statement) -> $6(cond) -> pDoWhile ->
           |                 |                |   |
           +-------------<<<------------------+   |
         *                   |                    |
         *  CONTINUE --------+                    |
         *  BREAK --------------------------------+
         */
        L_DO
        {
            IntR labelId = context->syntax_generate_unique_count();
            SyntaxContextState state = {
                VM_CONTEXT_WHILE,
                true,
                False,
                labelId,
                labelId,
            };
            $<context_state>$ = context->syntax_get_context_state();
            context->context_state = state;
        }
        statement L_WHILE '(' single_value ')' ';'
        {
            $$ = vm_genDoWhileSource(context, $6, $3);
            context->context_state = $<context_state>2;
        }
    ;

while:
        /*  $3(cond) -> pWhile -> $6(statement) -> pGoto ->
             |             |                         |   ^
             +-------------|----<<<------------------+   |
                           +------------->>>-------------+
         *
         * BREAK to last
         * CONTINUE to first node of $3
         */
        L_WHILE 
        {
            $<source_node>$ = vm_insertLineNode(context, NULL);
            $<number>1 = context->syntax_get_current_line();
        }
        '(' single_value ')' 
        {
            IntR labelId = context->syntax_generate_unique_count();
            SyntaxContextState state = {
                VM_CONTEXT_WHILE,
                true,
                False,
                labelId,
                labelId,
            };

            $<context_state>$ = context->syntax_get_context_state();
            context->context_state = state;
        }
        statement
        {
            $$ = vm_genWhileSource(context, $4, $7, $<number>1, context->syntax_get_current_line() + 1);
            $$ = vm_mergeSourceNode($<source_node>2, $$);
            context->context_state = $<context_state>6;
        }

for:
        L_FOR '(' for_expr ';' for_cond ';' for_expr ')' 
        {
            IntR labelId = context->syntax_generate_unique_count();
            SyntaxContextState state = {
                VM_CONTEXT_FOR,
                true,
                False,
                labelId,
                labelId,
            };

            $<source_node>1 = vm_insertLineNode(context, NULL);
            $<context_state>$ = context->syntax_get_context_state();
            $<number>2 = context->syntax_get_current_line();
            context->context_state = state;
        }
        statement
        {
            $$ = vm_genForSource(context, $3, $5, $7, $10, $<number>2, context->syntax_get_current_line() + 1);
            $$ = vm_mergeSourceNode($<source_node>1, $$);
            context->context_state = $<context_state>9;
        }
    |
        L_FOR '(' error ')'
        {
            _yyerror("Bad for expression/condition syntax");
        }
        statement
		{
			$$ = NULL;
		}
    ;

for_expr:
        /* empty */
        {
            $$ = NULL;
        }
    |
        single_value
        {
            $$ = $1;
        }
    ;

for_cond:
        /* empty */
        {
            $$ = NULL;
        }
    |
        single_value
        {
            $$ = $1;
        }
    ;

loop:
        /* $3(init) -> cond_jmp -> $6(statement) -> step_jmp ->
                           |        |                  /      ^
                           |        +-------<<<--------       |
                           +------------------>>>-------------+
         * BREAK to last
         * CONTINUE to first node of step_jmp
         */

		L_LOOP '(' loop_init ')'
		{
            IntR labelId = context->syntax_generate_unique_count();
            SyntaxContextState state = {
                VM_CONTEXT_LOOP,
                true,
                False,
                labelId,
                labelId,
            };
            AstElement *toElem = (AstElement *)vec_get($3, 3);

            $<context_state>$ = context->syntax_get_context_state();
            context->context_state = state;
            context->loopDepth ++;

            $<number>1 = context->syntax_get_current_line();

            /* make the register fixed, prevent from retrieve */
            if (toElem->regIndex != -1)
                vm_setRegisterFixed(context->syntax_get_current_function(), toElem->regIndex, true);
		}
		statement
		{
            AstLValueInfo *lv_info = vec_get($3, 0);
            AstExpression* exp = vec_get($3, 1);
            IntR type = (IntR)vec_get($3, 2);
            AstElement *toElem = vec_get($3, 3);

            $$ = vm_genLoopSource(context, lv_info, exp, type, toElem, $6, $<number>1, context->syntax_get_current_line() + 1);

            context->context_state = $<context_state>5;
            context->loopDepth --;
            vec_destruct($3);

            if (toElem->regIndex != -1)
                vm_setRegisterFixed(context->syntax_get_current_function(), toElem->regIndex, False);
		}
	;

loop_init:
		value_ptr_or_new_id_with_optional_assign to single_value
		{
            vec_append($1, (void*)$2);
            vec_append($1, $3);
            $$ = $1;
		}
	|
		value_ptr_or_new_id_with_optional_assign L_IN single_value
		{
            /* 0 means IN loop */
            vec_append($1, 0);
            vec_append($1, $3);
            $$ = $1;
		}
	;

to:
		L_UPTO
		{
            $$ = 1;
		}
	|
		L_DOWNTO
		{
            $$ = -1;
		}
	;

value_ptr_or_new_id_with_optional_assign:
		value_ptr_or_new_id optional_assign
		{
            Vector_T infoArr = vec_create(0);
            vec_append(infoArr, $1);
            vec_append(infoArr, $2);
            $$ = infoArr;
		}
	;

switch:
        L_SWITCH '(' single_value ')'
        {
            SyntaxContextState state = context->syntax_get_context_state();

            $<source_node>1 = vm_insertLineNode(context, NULL);
            $<context_state>$ = state;
            state.inSwitch = true;
            state.breakId = context->syntax_generate_unique_count();
            state.is_in_block = true;
            context->context_state = state; 
        }
        '{' switch_block '}'
        /*
         *   $3   pSwitch   pCase1   pCase2   ...  pDefault
         */
        {
            $$ = vm_genSwitchSource(context, $3, $7, context->syntax_get_current_line()); 
            $$ = vm_mergeSourceNode($<source_node>1, $$);
            context->context_state = $<context_state>5;
        }
    |
        L_SWITCH '(' error ')'
        {
            SyntaxContextState state = context->syntax_get_context_state();

            $<context_state>$ = state;
            state.inSwitch = true;
            state.breakId = context->syntax_generate_unique_count();
            state.is_in_block = true;
            context->context_state = state; 

            _yyerror("Bad parameter for switch.");
        }
        '{' switch_block '}'
        {
            context->context_state = $<context_state>5;
            $$ = NULL;
        }
    ;

switch_block:
        switch_block1
        {
            $$ = $1;
        }
    |
        statement switch_block1
        {
            _yyerror("Invalid statement in the switch block.");
            $$ = $2;
        }
    ;

switch_block1:
        case switch_block1
        {
            if ($1 == NULL)
                $$ = NULL;
            else
            {
                $1->pNext = $2;
                $$ = $1;
            }
        }
    |
        /* empty */
        {
            $$ = NULL;
        }
    ;

case:
        L_CASE
        {
            $<number>1 = context->syntax_get_current_line();
        }
        case_label ':' statements
        {
            AstCase *ca = context->syntax_create_case();
            ca->caseNumber = $3;
            ca->pBody = $5;
            ca->line = $<number>1;
            $$ = ca;
        }
    |
        L_CASE 
        {
            $<number>1 = context->syntax_get_current_line();
        }
        strings ':' statements
        {
            AstCase *ca = context->syntax_create_case();
            ca->caseString = syntax_add_back_slash_for_quote($3);
            ca->pBody = $5;
            ca->line = $<number>1;
            $$ = ca;
        }
    |
        L_CASE error ':'
        {
            _yyerror("Invalid case label: must be constant number or string.");
        }
        statements
        {
            $$ = NULL;
        }
	|
        L_CASE L_IDENTIFIER ':'
        statements
        {
			_yyerror("Invalid case label: Can't be variables or UNDEFINED.");
            $$ = NULL;
        }
    |
        L_DEFAULT ':' statements
        {
            AstCase *ca = context->syntax_create_case();
            ca->isDefault = 1;
            ca->pBody = $3;
            ca->line = context->syntax_get_current_line();
            $$ = ca;
        }
    |
        L_DEFAULT error ':'
        {
            _yyerror("Invalid parameter for default routine.");
        }
        statements
        {
            $$ = NULL;
        }
    ;

case_label:
        constant
        {
            $$ = $1;
        }
    ;

trace:
		L_TRACE '(' comma_expression ')' ';'
		{
#ifdef _DEBUG
            $$ = vm_genTraceSource(context, &$3);
#else
			/* For release version, ignore trace action */
			$$ = NULL;
#endif
		}
	|
		L_TRACE '(' ')' ';'
		{
			$$ = NULL;
		}
	;

shout:
		L_SHOUT '(' comma_expression ')' ';'
		{
            $$ = vm_genTraceSource(context, &$3);
		}
	|
		L_SHOUT '(' ')' ';'
		{
			$$ = NULL;
		}
	;

constant:
        constant '|' constant
        {
            $$ = $1 | $3;
        }
    |   constant '^' constant
        {
            $$ = $1 ^ $3;
        }
    |   constant '&' constant
        {
            $$ = $1 & $3;
        }
    |   constant L_EQ constant
        {
            $$ = $1 == $3;
        }
    |   constant L_NE constant
        {
            $$ = $1 != $3;
        }
    |   constant L_ORDER constant
        {
            switch($2){
                case F_GE: $$ = $1 >= $3; break;
                case F_LE: $$ = $1 <= $3; break;
                case F_GT: $$ = $1 >  $3; break;
            }
        }
    |   constant '<' constant
        {
            $$ = $1 < $3;
        }
    |   constant L_LSH constant
        {
            $$ = $1 << $3;
        }
    |   constant L_RSH constant
        {
            $$ = $1 >> $3;
        }
    |   constant '+' constant
        {
            $$ = $1 + $3;
        }
    |   constant '-' constant
        {
            $$ = $1 - $3;
        }
    |   constant '*' constant
        {
            $$ = $1 * $3;
        }
    |   constant '%' constant
        {
            if ($3) $$ = $1 % $3; else _yyerror("Modulo by zero.");
        }
    |   constant '/' constant
        {
            if ($3) $$ = $1 / $3; else _yyerror("Division by zero.");
        }
    |   '(' constant ')'
        {
            $$ = $2;
        }
    |   L_NUMBER
        {
            $$ = $1;
	    }
    |   '-' L_NUMBER
        {
            $$ = -$2;
        }
    |   L_NOT L_NUMBER
        {
            $$ = !$2;
        }
    |   '~' L_NUMBER
        {
            $$ = ~$2;
        }
    ;

catch:
        /* newCatch   $3   pop   push(0)   endCatch   pGoto   caught
         *     |                                        |        |       |
         *     |                                        +------->>-------+
         *     |                                                 |
         *     +------------------>>-----------------------------+
         */
        L_CATCH '(' single_value ')'
        {
            $$ = vm_genCatchElementFromElem(context, $3);
        }
	|
        /* newCatch   $2   push(0)   endCatch   pGoto   caught
         *     |                         |        |       |
         *     |                         +------->>-------+
         *     |                                  |
         *     +---------------->>----------------+
         */
        L_CATCH 
        {
            $<number>1 = context->context_state.is_in_block;
            context->context_state.is_in_block = true;
        }
        block
        {
            $$ = vm_genCatchElementFromBlock(context, $3);
            context->context_state.is_in_block = $<number>1;
        }
    ;

command:
        '\'' comma_expression ';'
        {
            AstFunctionDesc desc;
            AstElement *argElem = NULL, *elem = NULL;
            AstExpression* argExp = NULL;
            int size = (int) vec_size($2.expressions);
            int i = 0;

            // 创建"%O"参数
            argElem = context->syntax_create_element();
            argElem->type = VM_TYPE_STRING;
            argElem->isConstant = 1;
            argElem->source = NULL;
            argElem->output = vm_scratchCopyCStr("\"%O\"");
            argExp = context->syntax_create_expression(argElem);

            vec_scratch_insert($2.expressions, 0, argExp);

            // 创建函数调用的element
            desc.isGlobal = 1;
            desc.funName = "system.core.printf";
            desc.type = VM_SYN_FT_EFUN;
            desc.object = NULL;
            desc.retType = VM_TYPE_MIXED;

            elem = vm_genFunCallElement(context, desc, &$2);

            // 转化为SourceNode
            $$ = vm_newSourceNode(elem->source);

            // 回收对象
            context->syntax_destroy_element(elem);
            cmm_destroy_expressions(context, &$2);
        }
    |
        '\'' ';'
        {
            AstFunctionDesc desc;
            AstElement *elem = NULL;

            desc.isGlobal = 1;
            desc.funName = "system.debug.debug_quick_show_values";
            desc.type = VM_SYN_FT_EFUN;
            desc.object = NULL;
            desc.retType = VM_TYPE_MIXED;

            elem = vm_genFunCallElement(context, desc, NULL);

            $$ = vm_newSourceNode(elem->source);

            // 回收对象
            context->syntax_destroy_element(elem);
        }
    |
        L_OSFUN ';'
        {
            _yyerror("L_OSFUN not implemented yet.");
            $$ = NULL;
        }
    |
        L_OSFUN '(' ')' ';'
        {
            _yyerror("L_OSFUN not implemented yet.");
            $$ = NULL;
        }
    |
        L_OSFUN comma_expression ';'
        {
            _yyerror("L_OSFUN not implemented yet.");
            cmm_destroy_expressions(context, &$2);
            $$ = NULL;
        }
    ;

single_value:
        comma_expression
        {
            $$ = vm_genElementFromCommaExpression(context, $1);
        }
    ;

comma_expression:
        expression
        {
            AstExpression exps;
            
            // 在comma_expression无效的时候调用vec_destruct
            exps.expressions = vec_scratch_create(0);
            vec_scratch_append(exps.expressions, $1);
            $$ = exps; 
        }
    |
        comma_expression ',' expression
        {
            vec_scratch_append($1.expressions, $3);
            $$ = $1;
        }
    ;

expression:
        expr0
        {
            $$ = $1;
        }
    ;

expr0:
        L_INC value_ptr_or_new_id
        {
            AstExpression* expression = context->syntax_create_expression(NULL); 
            AstExpression* rightExp = context->syntax_create_expression(NULL);

            rightExp->pLv = $2;
            expression->pLeft = NULL;
            expression->pRight = rightExp;
            expression->op = L_INC;
            $$ = expression;
        }
    |
        L_DEC value_ptr_or_new_id
        {
            AstExpression* expression = context->syntax_create_expression(NULL); 
            AstExpression* rightExp = context->syntax_create_expression(NULL);

            rightExp->pLv = $2;
            expression->pLeft = NULL;
            expression->pRight = rightExp;
            expression->op = L_DEC;
            $$ = expression;
        }
    |
        value_ptr_or_new_id L_INC
        {
            AstExpression* expression = context->syntax_create_expression(NULL); 
            AstExpression* leftExp = context->syntax_create_expression(NULL);

            leftExp->pLv = $1;
            expression->pLeft = leftExp;
            expression->pRight = NULL;
            expression->op = L_INC;
            $$ = expression;
        }
    |
        value_ptr_or_new_id L_DEC
        {
            AstExpression* expression = context->syntax_create_expression(NULL); 
            AstExpression* leftExp = context->syntax_create_expression(NULL);

            leftExp->pLv = $1;
            expression->pLeft = leftExp;
            expression->pRight = NULL;
            expression->op = L_DEC;
            $$ = expression;
        }
    |
        value_ptr_or_new_id L_ASSIGN expr0
        {
            AstExpression* expression = context->syntax_create_expression(NULL);
            AstExpression* leftExp = context->syntax_create_expression(NULL);
            
            leftExp->pLv = $1;
            expression->pLeft = leftExp;
            expression->pRight = $3;
            expression->op = (Uint32) $2;

            $$ = expression;
        }
    |
        expr0 L_LAND expr0
        {
            AstExpression* expression = context->gen_op_const(L_LAND, $1, $3);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = $1;
                expression->pRight = $3;
                expression->op = L_LAND;
            }
            $$ = expression; 
        }
    |
        expr0 L_LOR expr0
        {
            AstExpression* expression = context->gen_op_const(L_LOR, $1, $3);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = $1;
                expression->pRight = $3;
                expression->op = L_LOR;
            }
            $$ = expression;
        }
    |
        expr0 '|' expr0
        {
            AstExpression* expression = context->gen_op_const('|', $1, $3);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = $1;
                expression->pRight = $3;
                expression->op = '|';
            }
            $$ = expression;
        }
    |   expr0 '^' expr0
        {
            AstExpression* expression = context->gen_op_const('^',  $1, $3);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = $1;
                expression->pRight = $3;
                expression->op = '^';
            }
            $$ = expression;
        }
    |   expr0 '&' expr0
        {
            AstExpression* expression = context->gen_op_const('&', $1, $3);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = $1;
                expression->pRight = $3;
                expression->op = '&';
            }
            $$ = expression; 
        }
    |   expr0 L_EQ expr0
        {
            AstExpression* expression = context->gen_op_const(L_EQ, $1, $3);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = $1;
                expression->pRight = $3;
                expression->op = L_EQ;
            }
            $$ = expression;           
        }
    |   expr0 L_NE expr0
        {
            AstExpression* expression = context->gen_op_const(L_NE, $1, $3);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = $1;
                expression->pRight = $3;
                expression->op = L_NE;
            }
            $$ = expression;
        }
    |   expr0 L_ORDER expr0
        {
            AstExpression* expression = context->gen_op_const((Uint32) $2, $1, $3);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = $1;
                expression->pRight = $3;
                expression->op = (Uint32) $2;
            }
            $$ = expression; 
        }
    |   expr0 '<' expr0
        {
            AstExpression* expression = context->gen_op_const(F_LT, $1, $3);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = $1;
                expression->pRight = $3;
                expression->op = '<';
            }
            $$ = expression;
        }
    |   expr0 L_LSH expr0
        {
            AstExpression* expression = context->gen_op_const(L_LSH, $1, $3);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = $1;
                expression->pRight = $3;
                expression->op = L_LSH;
            }
            $$ = expression;
        }
    |   expr0 L_RSH expr0
        {
            AstExpression* expression = context->gen_op_const(L_RSH, $1, $3);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = $1;
                expression->pRight = $3;
                expression->op = L_RSH;
            }
            $$ = expression;
        }
    |   expr0 '?' expr0 ':' expr0 %prec '?'
        {
            AstExpression* expression = context->syntax_create_expression(NULL);
            $$ = vm_genQuestionMarkExp(context, $1, $3, $5);
        }
    |   expr0 '+' expr0
        {
            AstExpression* expression = context->gen_op_const('+', $1, $3);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = $1;
                expression->pRight = $3;
                expression->op = (Uint32)'+';
            }
            $$ = expression;
        }
    |   expr0 '-' expr0
        {
            AstExpression* expression = context->gen_op_const('-', $1, $3);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = $1;
                expression->pRight = $3;
                expression->op = (Uint32)'-';
            }
            $$ = expression;
        }
    |   expr0 '*' expr0
        {
            AstExpression* expression = context->gen_op_const('*', $1, $3);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = $1;
                expression->pRight = $3;
                expression->op = (Uint32)'*';
            }
            $$ = expression;
        }
    |   expr0 '%' expr0
        {
            AstExpression* expression = context->gen_op_const('%', $1, $3);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = $1;
                expression->pRight = $3;
                expression->op = (Uint32)'%';
            }
            $$ = expression;
        }
    |   expr0 '/' expr0
        {
            AstExpression* expression = context->gen_op_const('/', $1, $3);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = $1;
                expression->pRight = $3;
                expression->op = (Uint32)'/';
            }
            $$ = expression;
        }
    |
        '-' expr0 %prec L_NOT
        {
            AstExpression* expression = context->gen_op_const('-', NULL, $2); 
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = NULL;
                expression->pRight = $2;
                expression->op = '-';
            }
            $$ = expression;
        }
    |
        L_NOT expr0
        {
            AstExpression* expression = context->gen_op_const(L_NOT, NULL, $2);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL); 
                expression->pLeft = NULL;
                expression->pRight = $2;
                expression->op = L_NOT;            
            }
            $$ = expression;
        }
    |
        '~' expr0
        {
            AstExpression* expression = context->gen_op_const('~', NULL, $2);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = NULL;
                expression->pRight = $2;
                expression->op = '~';
            }
            $$ = expression;
        }
    |
        cast expr0 %prec L_NOT
        {
            AstExpression* expression = vm_genCastConst(context, $2, $1.basicType);
            if (! expression)
            {
                expression = context->syntax_create_expression(NULL);
                expression->pLeft = NULL;
                expression->pRight = $2;
                expression->op = 'c';   /* 'c' means cast operation */
                expression->type = $1.basicType;
                expression->attrib = $1.varAttrib;

                if (expression->attrib & VM_VAR_CONST)
                {
                    /* Check type for value to cast to const */
                    if (expression->type != VM_TYPE_MAPPING &&
                        expression->type != VM_TYPE_ARRAY)
                    {
                        _yywarns("Line %d unused const for type %s.\n",
                                context->syntax_get_current_line(), vm_valueType(expression->type)); 
                    }
                }
            }
            $$ = expression;
        }
    |
        element
        {
            AstExpression* expression = context->syntax_create_expression($1);
            $$ = expression;
        }
    ;

element:
        L_NIL
        {
            AstElement *elem = context->syntax_create_element();
            elem->type = VM_TYPE_UNDEFINED;
            elem->isConstant = 0;
            elem->source = NULL;
            elem->output = vm_scratchCopyCStr("UNDEFINED");
            $$ = elem;
        }
    |
        L_REAL
        {
            char realBuffer[256];
            AstElement *elem = context->syntax_create_element();

            elem->type = VM_TYPE_REAL;
            elem->isConstant = 1;
            elem->source = NULL;
            SPRINTF(realBuffer, "%.12f", (double) $1);
            elem->output = vm_scratchCopyCStr(realBuffer);
            $$ = elem;
        }
    |
        L_FUNCTION_OPEN may_fun possible_arguments ':' ')'
        {
            $$ = vm_genNewFuncElement(context, $2, $3);
            cmm_destroy_expressions(context, &$3);
        }
    |
        L_IDENTIFIER
        {
            AstElement *elem = context->syntax_create_element();
            AstDeclare *decl = context->syntax_create_declare($1);

            elem->type = VM_TYPE_MIXED;
            elem->isConstant = 0;
            elem->source = NULL;
            elem->output = $1;
            $$ = elem;
            decl->type.basicType = VM_TYPE_MIXED;            
            decl->line = context->syntax_get_current_line();
            
            /* add a local variable */
            context->syntax_add_local_variable(decl);

            _yywarns("Line %d Undefined variable(%s), treat as undefined value.\n",
                    context->syntax_get_current_line(), $1); 
        }
    |
        L_EFUN
        {
            _yyerrors("Function \"%s\" missed arguments at line %d.\n",
                     $1.funName, context->syntax_get_current_line()); 

            /* return a fake element */
            $$ = context->syntax_create_element();
            $$->type = VM_TYPE_FUNCTION;
            $$->source = NULL;
            $$->output = $1.funName;
        }
    |
        L_FUN
        {
            _yyerrors("Function \"%s\" missed arguments at line %d.\n",
                     $1.funName, context->syntax_get_current_line());

            /* return a fake element */
            $$ = context->syntax_create_element();
            $$->type = VM_TYPE_FUNCTION;
            $$->source = NULL;
            $$->output = $1.funName;
        }
    |
        may_array_or_expr
        {
            $$ = $1;
        }
    |
        variable_value
        {
            AstElement *elem = context->syntax_create_element();

            if ($1.type.varAttrib & VM_VAR_MAY_NULL)
                elem->type = VM_TYPE_MIXED;
            else
                elem->type = $1.type.basicType;

            elem->isConstant = 0;
            elem->source = NULL;
            elem->output = $1.name;
            $$ = elem;
        }
    |
        value_ptr '[' single_value ']'
        {
            AstLValueInfo *lv_info = context->syntax_create_lvalue_info();
            lv_info->pAssignerValue = $1;
            lv_info->pIndexFrom = $3;
            $$ = vm_genElementFromLvInfo(context, lv_info);
        }
    |
    value_ptr '.' L_IDENTIFIER
        {
            AstElement *elem;
            AstLValueInfo *lv_info;
            
            elem = context->syntax_create_element();
            elem->type = VM_TYPE_STRING;
            elem->isConstant = 1;
            elem->source = NULL;
            elem->output = vm_scratchCopyFormatCStrs("\"%s\"", $3);
            
            lv_info = context->syntax_create_lvalue_info();
            lv_info->pAssignerValue = $1;
            lv_info->pIndexFrom = elem;
            $$ = vm_genElementFromLvInfo(context, lv_info);
        }
    |
        value_ptr '[' '<' single_value ']'
        {
            AstLValueInfo *lv_info = context->syntax_create_lvalue_info();
            lv_info->pAssignerValue = $1;
            lv_info->pIndexFrom = $4;
            lv_info->isReverseFrom = 1;
            $$ = vm_genElementFromLvInfo(context, lv_info);
        }
    |
        value_ptr '[' single_value L_RANGE single_value ']'
        {
            AstLValueInfo *lv_info = context->syntax_create_lvalue_info();
            lv_info->pAssignerValue = $1;
            lv_info->pIndexFrom = $3;
            lv_info->pIndexTo = $5;
            $$ = vm_genElementFromLvInfo(context, lv_info);
        }
    |
        value_ptr '[' single_value L_RANGE '<' single_value ']'
        {
            AstLValueInfo *lv_info = context->syntax_create_lvalue_info();
            lv_info->pAssignerValue = $1;
            lv_info->pIndexFrom = $3;
            lv_info->pIndexTo = $6;
            lv_info->isReverseTo = 1;
            $$ = vm_genElementFromLvInfo(context, lv_info);
        }
    |
        value_ptr '[' '<' single_value L_RANGE '<' single_value ']'
        {
            AstLValueInfo *lv_info = context->syntax_create_lvalue_info();
            lv_info->pAssignerValue = $1;
            lv_info->pIndexFrom = $4;
            lv_info->pIndexTo = $7;
            lv_info->isReverseFrom = 1;
            lv_info->isReverseTo = 1;
            $$ = vm_genElementFromLvInfo(context, lv_info);
        }
    |
        '$' L_NUMBER
        {
            AstElement *elem = context->syntax_create_element();
            AstFunction *curFunc = context->syntax_get_current_function();
            IntR regIndex = vm_allocRegister(curFunc, VM_TYPE_MIXED); 
            char output[64];
            char source[128];
    
            SPRINTF(output, "@r_%d", (int) regIndex);
            SPRINTF(source, "getparam_xi %s, %d;\n", output, (int) ($2 - 1));
        
            elem->type = VM_TYPE_MIXED;
            elem->output = vm_scratchCopyCStr(output);
            elem->source = vm_scratchCopyCStr(source);
            elem->regIndex = regIndex;
    
            $$ = elem;
        }
    |
        '$' '(' single_value ')'
        {
            AstElement *elem = context->syntax_create_element();
            AstFunction *curFunc = context->syntax_get_current_function();
            char output[64];
            IntR regIndex = vm_allocRegister(curFunc, VM_TYPE_MIXED); 
            char *buffer = vm_getGlobalBuf(VM_GLOBAL_BUF_SIZE, __FUNCTION__);
            buffer[0] = '\0';

            SPRINTF(output, "@r_%d", (int) regIndex);
            
            if ($3->source)
                _APPEND_SRC("%s", $3->source);
        
            _APPEND_SRC("getparam_x%c %s, %s;\n", vm_getTypeChar($3->type), output, $3->output);
        
            elem->type = VM_TYPE_MIXED;
            elem->output = vm_scratchCopyCStr(output);
            elem->source = vm_scratchCopyCStr(buffer);
            elem->regIndex = regIndex;
    
            $$ = elem;

            vm_releaseGlobalBuf(buffer, __FUNCTION__);
        }
	|
		'$' '<'
		{
            AstElement *elem = context->syntax_create_element();
            AstFunction *curFunc = context->syntax_get_current_function();
            char output[64];
            char source[128];
    
            IntR regIndex = vm_allocRegister(curFunc, VM_TYPE_ARRAY); 
            SPRINTF(output, "@r_%d", (int) regIndex);
            SPRINTF(source, "createparams_%c %s;\n",
                    vm_getTypeChar(VM_TYPE_ARRAY), output);
        
            elem->type = VM_TYPE_ARRAY;
            elem->output = vm_scratchCopyCStr(output);
            elem->source = vm_scratchCopyCStr(source);
            elem->regIndex = regIndex;
    
            $$ = elem;
		}
    |
        '$' '?'
        {
            AstElement *elem = context->syntax_create_element();
            AstFunction *curFunc = context->syntax_get_current_function();
            char output[64];
            char source[128];

            IntR regIndex = vm_allocRegister(curFunc, VM_TYPE_NUMBER);
            SPRINTF(output, "@r_%d", (int) regIndex);
            SPRINTF(source, "paramnum_%c %s;\n", vm_getTypeChar(VM_TYPE_NUMBER), output);
            
            elem->type = VM_TYPE_NUMBER;
            elem->output = vm_scratchCopyCStr(output);
            elem->source = vm_scratchCopyCStr(source);
            elem->regIndex = regIndex;
            
            $$ = elem;
        }
    |
        '&' value_ptr_or_new_id
        {
            AstElement *elem = vm_genElementFromLvInfo(context, $2);
            elem->isRef = true;
            if ($2->pAssignerValue != NULL)
                _yyerror("Indexed value should not be referenced.\n");

            /* There is a problem: If user put a non-valid type value in
             * refered value, it may cause crash */
////----            if ($2->pElemValue->type != VM_TYPE_MIXED)
////----                _yywarn("Non mixed type value should not be referenced.\n");

            $$ = elem;
        }
    |
        L_IS_REF '(' identifier ')'
        {
            _yyerror("is_ref is not support anymore!");
            $$ = NULL;
            _yystop();
        }
    |
        L_IS_REF '(' '$' L_NUMBER ')'
        {
            _yyerror("is_ref is not support anymore!");
            $$ = NULL;
            _yystop();
        }
    |
        L_IS_REF '(' '$' '(' single_value ')' ')'
        {
            _yyerror("is_ref is not support anymore!");
            $$ = NULL;
            _yystop();
        }
    |
        L_IS_REF '(' error ')'
        {
            _yyerror("is_ref is not support anymore!");
            $$ = NULL;
            _yystop();
        }
    |
        catch
        {
            $$ = $1;
        }
    ;

efun_or_fun:
        L_EFUN
        {
            $$ = $1;
        }
    |
        L_FUN
        {
            $$ = $1;
        }
    ;

possible_arguments:
        /* empty */
        {
            AstExpression emptyExp;
            emptyExp.expressions = NULL;
            $$ = emptyExp;
        }
    |
        ',' comma_expression
        {
            $$ = $2;
        }
    ;

may_array_or_expr:
        L_NUMBER
        {
            AstElement *elem;
            char str[128];
			vm_intToString(str, sizeof(str), $1, 10, 1, 0);
            elem = context->syntax_create_element();
            elem->isConstant = 1;
            elem->source = NULL;
            elem->type = VM_TYPE_NUMBER;
            elem->output = vm_scratchCopyCStr(str);
            $$ = elem;
        }
    |
        strings
        {
            AstElement *elem;
            char *str = syntax_add_back_slash_for_quote($1);
            if (str == NULL)
            {
                _yyerror("Invalid string.");
                str = vm_scratchCopyCStr("");
            }

            elem = context->syntax_create_element();
            elem->isConstant = 1;
            elem->source = NULL;
            elem->type = VM_TYPE_STRING;
            elem->output = str;

            $$ = elem;
        }
    |
       '(' single_value ')'
        {
            $$ = $2;
        }
    |
        L_CALL '(' ')'
        {
            _yyerror("Missed function to call.");
            _yystop();
        }
    |
        L_CALL '(' comma_expression ')'
        {
            $$ = vm_genCallElement(context, &$3, NULL);
            cmm_destroy_expressions(context, &$3);
        }
    |
        '$' identifier
        {
            _yyerror("Not support now.");
            $$ = NULL;
            _yystop();
        }
    |
        '$' identifier '(' ')'
        {
            _yyerror("Not support now.");
            $$ = NULL;
            _yystop();
        }
    |
        '$' identifier '(' comma_expression ')'
        {
            cmm_destroy_expressions(context, &$4);
            _yyerror("Not support now.");
            $$ = NULL;
            _yystop();
        }
    |
        fun_call
        {
            $$ = $1;
        }
    |
        L_ARRAY_OPEN comma_expression possible_comma '}' ')'
        {
            $$ = vm_genArrayElement(context, &$2);
            cmm_destroy_expressions(context, &$2);
        }
    |
        L_ARRAY_OPEN possible_comma '}' ')'
        {
            $$ = vm_genArrayElement(context, NULL);
        }
    |
        L_MAPPING_OPEN mapping_pairs ']' ')'
        {
            $$ = vm_genMappingELement(context, $2);
        }
    ;

may_object: 
        variable
        {
            AstElement *elem = context->syntax_create_element();
            elem->type = $1.type.basicType;
            elem->output = $1.name;
            $$ = elem;
        }
    |
        may_array_or_expr
        {
            $$ = $1;
        }
    ;

fun_call:
        '(' '*' element ')' '(' ')'
        {
            $$ = vm_genCallElement(context, NULL, $3);
        }
    |
        '(' '*' element ')' '(' comma_expression ')'
        {
            $$ = vm_genCallElement(context, &$6, $3);
            cmm_destroy_expressions(context, &$6);
        }
    |
        may_fun '(' ')'
        {
            $$ = vm_genFunCallElement(context, $1, NULL);
        }
    |
        may_fun '(' comma_expression ')'
        {
            $$ = vm_genFunCallElement(context, $1, &$3);
            cmm_destroy_expressions(context, &$3);
        }
    |
        may_object L_ARROW identifier_to_be_finalized '(' ')'
        {
            AstFunctionDesc function_desc;
            function_desc.isGlobal = 0;
            function_desc.funName = $3;
            function_desc.object = $1;
            function_desc.type = VM_SYN_FT_OBJECT_FUN;
            function_desc.retType = VM_TYPE_MIXED;
            $$ = vm_genFunCallElement(context, function_desc, NULL);
        }
    |
        may_object L_ARROW identifier_to_be_finalized '(' comma_expression ')'
        {
            AstFunctionDesc function_desc;
            function_desc.isGlobal = 0;
            function_desc.funName = $3;
            function_desc.object = $1;
            function_desc.type = VM_SYN_FT_OBJECT_FUN;
            function_desc.retType = VM_TYPE_MIXED;
            $$ = vm_genFunCallElement(context, function_desc, &$5);
            cmm_destroy_expressions(context, &$5);
        }
    |
        may_object L_EXPAND_ARROW identifier_to_be_finalized '(' ')'
        {
            AstFunctionDesc function_desc;
            function_desc.isGlobal = 0;
            function_desc.funName = $3;
            function_desc.object = $1;
            function_desc.type = VM_SYN_FT_USER_FUN;
            function_desc.retType = VM_TYPE_MIXED;
            $$ = vm_genFunCallElement(context, function_desc, NULL);
        }
    |
        may_object L_EXPAND_ARROW identifier_to_be_finalized '(' comma_expression ')'
        {
            AstFunctionDesc function_desc;
            function_desc.isGlobal = 0;
            function_desc.funName = $3;
            function_desc.object = $1;
            function_desc.type = VM_SYN_FT_USER_FUN;
            function_desc.retType = VM_TYPE_MIXED;
            $$ = vm_genFunCallElement(context, function_desc, &$5);
            cmm_destroy_expressions(context, &$5);
        }
    ;

mapping_pairs:
        /* empty */
        {
            $$ = NULL;
        }
    |
        mapping_pair
        {
            $$ = $1;
        }
    |
        mapping_pair ',' mapping_pairs
        {
            $1->pNext = $3;
            $$ = $1;
        }
    ;

mapping_pair:
        expression ':' expression
        {
            SyntaxMappingPair *pair = vm_scratchAlloc(sizeof(*pair));
            pair->expKey = $1;
            pair->expValue = $3;
            pair->pNext = NULL;
            $$ = pair;
        }
    ;

possible_comma:
        /* empty */
    |
        ','
    ;

cast:
        '(' var_type ')'
        {
            if ($2.basicType == VM_TYPE_VOID || $2.basicType == VM_TYPE_UNDEFINED)
                _yyerror("Invalid type to cast.");

            $$ = $2;
        }
    ;

value_ptr_or_new_id:
        assignable_ptr
        {
            $$ = $1;
        }
    |
        L_IDENTIFIER
        {
            AstDeclare *decl = context->syntax_create_declare($1);
            AstLValueInfo *lv_info = context->syntax_create_lvalue_info();
            AstElement *elem = context->syntax_create_element();

            decl->type.basicType = VM_TYPE_MIXED;
            decl->line = context->syntax_get_current_line();
            elem->type = VM_TYPE_MIXED;
            elem->source = NULL;
            elem->isConstant = 0;
            elem->output = vm_scratchCopyCStr($1);
            lv_info->pElemValue = elem;

            // 作为局部变量
            if (context->m_in_function)
            {
                // 添加到局部变量
                context->syntax_add_local_variable(decl);

                // 警告一下
                _yywarns("Local variable(%s) in function \"%s\" used without declaration.\n",
                        $1, context->m_in_function->name);
            }
            else
            {
                // 添加到成员变量
                context->syntax_add_member_variable(decl);
            }

            $$ = lv_info;
        }
    ;

variable_value:
        variable
        {
            $$ = $1;
        }
    ;

value_ptr:  /* This type may not be assigned */
        assignable_ptr
        {
            $$ = $1;
        }
    |
        may_array_or_expr
        {
            AstLValueInfo *lv = context->syntax_create_lvalue_info(); 
            AstElement *elem = $1;
            lv->pElemValue = elem;
            $$ = lv;
        }
    ;

assignable_ptr: /* This type can be assigned */
        variable
        {
            AstLValueInfo *lv = context->syntax_create_lvalue_info(); 
            AstElement *elem = context->syntax_create_element();

            elem->type = $1.type.basicType;
            elem->isConstant = 0;
            elem->source = NULL;
            elem->output = $1.name;
            lv->pElemValue = elem;
            $$ = lv;
        }
    |
        '$' L_NUMBER
        {
            _yyerror("Not support argument assign.");
            $$ = NULL;
            _yystop();
        }
    |
        '$' '(' single_value ')'
        {
            _yyerror("Not support argument assign.");
            $$ = NULL;
            _yystop();
        }
    |
        value_ptr '[' single_value ']'
        {
            AstLValueInfo *lv = context->syntax_create_lvalue_info();
            lv->pAssignerValue = $1;
            lv->pIndexFrom = $3;
            $$ = lv;
        }
    |
        value_ptr '.' L_IDENTIFIER
        {
            AstElement *elem;
            AstLValueInfo *lv_info;
            
            elem = context->syntax_create_element();
            elem->type = VM_TYPE_STRING;
            elem->isConstant = 1;
            elem->source = NULL;
            elem->output = vm_scratchCopyFormatCStrs("\"%s\"", $3);
            
            lv_info = context->syntax_create_lvalue_info();
            lv_info->pAssignerValue = $1;
            lv_info->pIndexFrom = elem;
            $$ = lv_info;
        }
    |
        value_ptr '[' '<' single_value ']'
        {
            AstLValueInfo *lv = context->syntax_create_lvalue_info();
            lv->pAssignerValue = $1;
            lv->pIndexFrom = $4;
            lv->isReverseFrom = 1;
            $$ = lv;
        }
    |
        value_ptr '[' single_value L_RANGE single_value ']'
        {
            AstLValueInfo *lv = context->syntax_create_lvalue_info();
            lv->pAssignerValue = $1;
            lv->pIndexFrom = $3;
            lv->pIndexTo = $5;
            $$ = lv;
        }
    |
        value_ptr '[' single_value L_RANGE '<' single_value ']'
        {
            AstLValueInfo *lv = context->syntax_create_lvalue_info();
            lv->pAssignerValue = $1;
            lv->pIndexFrom = $3;
            lv->pIndexTo = $6;
            lv->isReverseTo = 1;
            $$ = lv;
        }
    |
        value_ptr '[' '<' single_value L_RANGE '<' single_value ']'
        {
            AstLValueInfo *lv = context->syntax_create_lvalue_info();
            lv->pAssignerValue = $1;
            lv->pIndexFrom = $4;
            lv->pIndexTo = $7;
            lv->isReverseFrom = 1;
            lv->isReverseTo = 1;
            $$ = lv;
        }
    ;

may_fun:
        efun_or_fun
        {
            $$ = $1;
        }
    |
        L_IDENTIFIER
        {
            // TODO:在DefaultObject中查找
            _yyerrors("Function \"%s\" at line %d hasn't been declared.\n",
                         $1, context->syntax_get_current_line()); 
    
            $$.type = VM_SYN_FT_UNKNOWN;
            $$.retType = VM_TYPE_MIXED;
            $$.funName = NULL;
            $$.isGlobal = 0;
            $$.object = NULL;
        }
    |
        L_COLON_COLON efun_or_fun
        {
            if ($2.type == VM_SYN_FT_EFUN)
                _yyerrors("Can't access overrided external function \"%s\" at line %d.\n",
                         $2.funName, context->syntax_get_current_line());

            if (! context->m_in_function)
            {
                _yyerrors("Can't access overrided function \"%s\" at line %d.\n",
                     $2.funName, context->syntax_get_current_line());
            }
            else
            {
                // 查找inherit对象上的函数    
                Vm_Object_T *inheritObj = NULL;
                Vm_Program_T *inheritProgram = NULL;
                Vm_Fun_T *func = NULL;
                IntR size = vec_size(context->inherits);
                IntR i = 0;
                IntR isFind = 0;

                for (i = 0; i < size; ++i)
                {
                    inheritObj = vec_get(context->inherits, i);
                    VM_ASSERT(inheritObj);

                    inheritProgram = inheritObj->pProgram;
                    VM_ASSERT(inheritProgram);

                    func = vm_findProgramFunctionByCStr(inheritProgram, $2.funName, 0, NULL);
                    if (func)
                    {
                        $2.type = VM_SYN_FT_FATHER_FUN;
                        $2.retType = VM_TYPE_MIXED;
                        $2.isGlobal = 0;
                        isFind = 1;
                        break;
                    }
                }
                
                if (! isFind)
                   _yyerrors("No overrided function \"%s\".\n", $2.funName); 
            }

            $$ = $2;
        }
	|
		L_GLOBAL efun_or_fun
		{
            Vm_Fun_T *fun;
            Vm_Efun_T *efun;

            /* global function */
            fun = vm_findProgramFunctionByCStr(vm_pGlobalProgram, $2.funName, 0, NULL);
            if (fun)
               $2.type = VM_SYN_FT_GLOBAL_FUN;
        
            /* external function */
            efun = syntax_lookup_efun(context, $2.funName);
            if (efun)
                $2.type = VM_SYN_FT_EFUN;
                        
            if (! fun && ! efun)
            {
                _yyerrors("No such global function \"%s\" at line %d.\n", 
                    $2.funName, context->syntax_get_current_line());
            }            

            $$ = $2;
		}
	|
		L_GLOBAL identifier
		{
            _yyerrors("No such global function \"%s\" at line %d.\n",
                     $2, context->syntax_get_current_line());

            $$.type  = VM_SYN_FT_UNKNOWN;
            $$.retType = VM_TYPE_MIXED;
            $$.funName = NULL;
            $$.isGlobal = 0;
		}
    |
        L_COLON_COLON identifier
        {
            _yyerrors("Can't access overrided function \"%s\" at line %d.\n",
                     $2, context->syntax_get_current_line());
                     
            $$.type = VM_SYN_FT_UNKNOWN;
            $$.retType = VM_TYPE_MIXED;
            $$.funName = NULL;
            $$.isGlobal = 0;
        }
    ;

strings:
        L_STRING strings
        {
            $$ = vm_scratchJoin($1, $2);
        }
    |
        L_STRING
        {
            $$ = vm_scratchCopyCStr($1);
        }
    ;

variable:
        L_GLOBAL L_DEFINED_NAME
        {
            $$ = $2;
        }
    |
        L_DEFINED_NAME
        {
            $$ = $1;
        }
    ;

identifier:
        L_DEFINED_NAME
        {
            $$ = $1.name;
	    }
     |
        L_IDENTIFIER
        {
            $$ = $1;
        }
     ;

identifier_to_be_finalized:
        L_EFUN
        {
            $$ = $1.funName;
        }
    |
        L_FUN
        {
            $$ = $1.funName;
        }
    |
        L_DEFINED_NAME
        {
            $$ = $1.name;
	    }
    |
        L_IDENTIFIER
        {
            $$ = $1; 
        }
    ;
%%

/* Destruct expressions */
static void cmm_destroy_expressions(LangContext* context, AstExpressions* exps)
{
    BUFFER_DELETE(exps); 
}

/* Call parser */
static void cmm_lang_parse(LangContext* context)
{
    context->parse();
}

} // End of namespace: cmm
