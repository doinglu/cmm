// cmm_grammar.y:
// Initial version 2001.12.12 by doing
// Updated 2011.6.30 by shenyq
// Immigrated 2015.10.29 by doing

%parse-param {Lang *context}

%{
// Don't be worried about the possible warnings.
// This file is generated by YACC.

#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#define YYSTACK_USE_ALLOCA      1

#include "cmm.h"
#include "cmm_buffer_new.h"
#include "cmm_efun.h"
#include "cmm_program.h"
#include "cmm_common_util.h"
#include "cmm_lang.h"
#include "cmm_lexer.h"
#include "cmm_register_allocator.h"
#include "cmm_value.h"

namespace cmm
{

#define isalunum(c) (isalnum(c) || (c) == '_')

#define MAX_COMPILER_ERRORS     64
#define YYDEBUG 0

#define malloc(size)    std_allocate_memory(size, "yacc", __FILE__, __LINE__);
#define free(ptr)       std_free_memory(ptr, "yacc", __FILE__, __LINE__);

#define yyerror         Lang::syntax_error
#define yyerrors        Lang::syntax_errors
#define yywarn          Lang::syntax_warn
#define yywarns         Lang::syntax_warns

#define _yyerror(str)   yyerror(context, str)
#define _yyerrors(...)  yyerrors(context, __VA_ARGS__)
#define _yywarn(str)    yy_warn(context, str)
#define _yywarns(...)   yy_warns(context, __VA_ARGS__)
#define _yystop()       Lang::syntax_stop(context, ErrorCode::COMPILE_ERROR)

// Define the "yyparse" as a macro in case of name conflict with other
// files generated by YACC
#define yyparse         cmm_lang_parse
#define yylex           context->m_lexer.lex_in

%}

/*
 * Token definitions.
 *
 * Appearing in the precedence declarations are:
 *      '+'  '-'  '/'  '*'  '%'
 *      '&'  '|'  '<'  '>'  '^'
 *      '~'  '?'
 *
 * Other single character tokens recognized in this grammar:
 *      '{'  '}'  ','  ';'  ':'
 *      '('  ')'  '['  ']'  '$'
 */

%token L_STRING L_NUMBER L_REAL
%token L_BASIC_TYPE
%token L_IDENTIFIER
%token L_LABEL
%token L_NIL
%token L_IS_REF

%token L_ADD_COMPONENT

%token L_INC L_DEC
%token L_ASSIGN
%token L_LAND L_LOR
%token L_LSH L_RSH
%token L_ORDER
%token L_NOT
%token L_REV
%token L_ADD L_SUB L_MUL L_DIV L_MOD
%token L_OR L_AND L_XOR
%token L_LT

%token L_BUILD
%token L_IF L_ELSE
%token L_SWITCH L_CASE L_DEFAULT L_RANGE L_DOT_DOT_DOT
%token L_WHILE L_DO L_FOR
%token L_LOOP L_UPTO L_DOWNTO L_EACH L_IN
%token L_BREAK L_CONTINUE
%token L_ARROW L_EXPAND_ARROW L_COLON_COLON
%token L_ARRAY_OPEN L_MAPPING_OPEN L_FUNCTION_OPEN
%token L_GOTO
%token L_CALL
%token L_RETURN
%token L_TRACE L_SHOUT
%token L_GLOBAL

%token L_TRY L_CATCH

%token L_PRIVATE L_PUBLIC
%token L_OVERRIDE L_NOMASK
%token L_STATIC
%token L_NOSAVE
%token L_CONST

%union
{
    Integer             number;
    Real                real;
    StringImpl*         string;

    AstNode*            node;
    AstCase*            cases;
    AstDeclare*         declares;
    AstExpr*            expression;
    AstExpr*            expr_list;
    AstFunction*        function;
    AstFunctionArg*     argument;
    AstFunctionArgsEx   arguments_ex;
    AstLValue*          lvalue;
    AstPrototype*       prototype;

    ValueType           basic_var_type;
    Uint8               var_attrib;
    VarType             var_type;

    bool                bool_flag;
    Uint32              uint32_val;
}

/*
 * 'Dangling else' shift/reduce conflict is well known...
 *  define these precedences to shut yacc up.
 */

%nonassoc LOWER_THAN_ELSE
%nonassoc L_ELSE

/*
 * Operator precedence and associativity...
 * greatly simplify the grammar.
 */

%right L_ASSIGN
%right '?'
%right ':'
%left L_LOR
%left L_LAND
%left L_OR
%left L_XOR
%left L_AND
%left L_EQ L_NE
%left L_ORDER L_LT
%left L_LSH L_RSH
%left L_ADD L_SUB
%left L_MUL L_MOD L_DIV
%right L_NOT
%left '.'
%left L_ARROW
%left '['
%nonassoc L_INC L_DEC

// Type declarations.

// These hold opcodes
%type <uint32_val>      L_ASSIGN L_ORDER

// These hold arbitrary numbers
%type <number>          L_NUMBER

// These hold a signal number (-1/+1)
%type <number>          to

// These hold a real number
%type <real>            L_REAL

// holds a string constant
%type <string>          L_STRING strings

// These hold a list of possible interpretations of an identifier
%type <string>          L_LABEL

// These hold a type
%type <var_type>        cast var_type

// These hold a basic type
%type <basic_var_type>  L_BASIC_TYPE

// These hold var type attrib
%type <var_attrib>      var_attrib optional_question_mark optional_and

// These hold a function type
%type <number>          fun_attrib  fun_type

// These hold a string
%type <string>          L_IDENTIFIER identifier

// These hold a declaration of variable(s)
%type <declares>        declare_vars declare_1_var 

// These hold a serial of ast node
%type <node>            declaration 
%type <node>            statement statements
%type <node>            add_component
%type <node>            block label
%type <node>            try_catch 
%type <node>            if for loop optional_else_part
%type <node>            do while goto switch
%type <node>            loop_init
%type <node>            trace shout
%type <node>            command
%type <expr_list>       mapping_pairs mapping_pair
%type <function>        function
%type <prototype>       prototype raw_prototype
%type <argument>        arg_list new_arg
%type <arguments_ex>    arguments_ex
%type <cases>           switch_block switch_block1 case
%type <expression>      expr0 comma_expression 
%type <expression>      optional_assign possible_arguments
%type <expression>      for_init for_cond for_step
%type <expression>      constant case_label
%type <expression>      element fun_call single_value catch

%%

all:
        {            
        }
        statements
        {
            // 仅当没有错误的时候进行后续处理
            if (context->m_num_errors == 0)
            {
            }
            else
            {
                printf("Total %d errors %d warning.\n", context->m_num_errors, context->m_num_warnings);
            }
        }
    ;

statements:
        // empty
        {
            $$ = 0;
        }
    |
        statement statements
        {
            $$ = append_sibling_node($1, $2);
        }
    |
        add_component statements
        {
            $$ = $2;
        }
    |
        function statements
        {
            $$ = append_sibling_node($1, $2);
        }
    |
        declaration 
        {
            // 回收寄存器
            if (context->m_in_function == 0)
            {
////----                cmm_free_ret_registers(context->m_entry_function);
            }
            else
            {
////----                cmm_free_ret_registers(context->m_in_function);
            }
        }
        statements
        {
            $$ = append_sibling_node($1, $3);
        }
    |
        error
        {
            $$ = 0;
        }
    ;

block:
	    '{' statements '}'
        {
            $$ = $2;

            // Popup context
            // More to be added
        }
    ;

try_catch:
		L_TRY block L_CATCH block
		{
            // More to be added
		}
	;

label:
        identifier ':'
        {
            auto* node = BUFFER_NEW(AstLabel);
            node->name = $1;
            $$ = node;
        }
    ;

statement:
        error ';'
        {
            _yyerror("Illegal statement.");
            $$ = 0;
        }
    |
        ';'
        {
            $$ = 0;
        }
    |
        single_value ';'
        {
            $$ = $1;
        }
    |   label
    |   block
    |   if
    |   for
	|   loop
    |   do
    |   while
	|	try_catch
    |   switch
    |   goto
	|   trace
    |   shout
    |
        L_BREAK ';'
        {
            auto* node = BUFFER_NEW(AstGoto);
            if (context->m_context_state.is_in_loop)
            {
                node->goto_type = AstGotoType::AST_BREAK_CASE;
            } else
            if (context->m_context_state.is_in_switch)
            {
                node->goto_type = AstGotoType::AST_BREAK_LOOP;
            } else
                _yyerror("Break mismatched loop or switch.");
            $$ = node;
        }
    |
        L_CONTINUE ';'
        {
            if (context->m_context_state.is_in_loop)
            {
                auto* node = BUFFER_NEW(AstGoto);
                node->goto_type = AstGotoType::AST_CONTINUE_LOOP;
                $$ = node;
            } else
            {
                _yyerror("Continue mismatched loop or switch.");
                $$ = 0;
            }
        }
    |
        L_RETURN ';'
        {
            auto* node = BUFFER_NEW(AstReturn);
            node->expr = 0;
            $$ = node;
        }
    |
        L_RETURN single_value ';'
        {
            auto* node = BUFFER_NEW(AstReturn);
            node->expr = $2;
            $$ = node;

            // change the entry function type
            if (!context->m_in_function)
                context->m_entry_function->prototype->ret_var_type.basic_var_type = MIXED;
        }
    |
        command
        {
            $$ = $1;
        }
    ;

add_component:
        L_ADD_COMPONENT strings ';' 
        {
            context->syntax_add_component($2);
        }
    ;

function:
        prototype 
        {
            context->m_in_function = $1;
        }
        '{' statements '}'
        {
            auto* node = BUFFER_NEW(AstFunction);
            // 函数体
            node->prototype = $1;
            node->body = $4;

            // 恢复为空
            context->m_in_function = 0;
            
            $$ = node;
        }
    |
        prototype ';'
        {
            _yyerror("Missed function body.");
            $$ = 0;
        }
    |
        prototype error
        {
            _yyerror("Bad function body, expected \"{ ... }\".");
            $$ = 0;
        }
    ;

prototype:
        fun_type raw_prototype
        {
            $2->attrib |= $1;
            $$ = $2;
        }
    |
        raw_prototype
        {
            $$ = $1;
        }
    ;

fun_type:
        fun_attrib
        {
            $$ = $1;
        }
    |
        fun_type fun_attrib
        {
            $$ = $1 | $2;            

            if ($$ != 0xFFFFFFFF)
            {
                if (($$ & AST_PRIVATE) && ($$ & AST_PUBLIC))
                {
                    $$ = 0xFFFFFFFF;
                    _yyerror("private conflict with public.");
                } 
            }
        }
    ;

fun_attrib:
        L_PRIVATE
        {
            $$ = AST_PRIVATE;
        }
    |
        L_PUBLIC
        {
            $$ = AST_PUBLIC;
        }
    |
        L_OVERRIDE
        {
            $$ = AST_OVERRIDE;
        }
    |
        L_NOMASK
        {
            $$ = AST_UNMASKABLE;
        }
    ;

raw_prototype:
        var_type identifier
        {
            // 构造函数结构
            auto* node = BUFFER_NEW(AstPrototype);
            node->name = $2;

            if (context->m_in_function)
            {
                // More to be added
                _yyerror("Can not declare a function inside a function.");
                _yystop();
            }            

            // consider current attribute
            if (context->m_current_attrib & AST_OVERRIDE)
                node->attrib |= AST_OVERRIDE;

            // constructor or destructor must be private
            if (*$2 == "create" || *$2 == "destruct")
                node->attrib |= AST_PRIVATE;

            // 设置当前函数
            context->m_in_function = node;
        }
         '(' arguments_ex ')'
        {
            auto *node = context->m_in_function;

            node->ret_var_type = $1;
            node->arg_list = $5.arg_list;
            if ($5.ddd)
                node->attrib |= AST_RANDOM_ARG;

            $$ = node; 
            
            context->m_in_function = 0;
        }
    ;

var_type:
        var_attrib L_BASIC_TYPE optional_question_mark
        {
            VarType var_type;
            var_type.basic_var_type = $2;
            var_type.var_attrib = ($1 | $3);
            $$ = var_type;
        }
    ;

var_attrib:
		// Empty
		{
            $$ = 0;
		}
	|
		L_NOSAVE var_attrib
		{
            $$ = AST_VAR_NO_SAVE | $2;
		}
    |
        L_CONST var_attrib
        {
            $$ = AST_VAR_CONST | $2;
        }
	;

arguments_ex:
        // empty
        {
            $$.arg_list = 0;
            $$.ddd = 0;
        }
    |
        L_DOT_DOT_DOT
        {
            $$.arg_list = 0;
            $$.ddd = 1;
        }
    |
        arg_list
        {
            $$.arg_list = $1;
            $$.ddd = 0;
        }
    |
        arg_list L_DOT_DOT_DOT
        {
            $$.arg_list = $1;
            $$.ddd = 1;
        }
    ;

arg_list:
        new_arg
        {
            $$ = $1;
        }
    |
        new_arg ',' arg_list
        {
            if ($1 != 0)
            {
                // Check default value
                if ($1->default_value != 0 && $3->default_value == 0)
                    _yyerror("Bad argument, miss default value.\n");
            }
            $$ = (AstFunctionArg*)append_sibling_node($1, $3);
        }
    ;

new_arg:
        error
        {
            $$ = 0;
        }
    |
        var_type optional_and identifier optional_assign
        {
            if ($1.basic_var_type == TVOID || $1.basic_var_type == NIL)
			{
	            $$ = 0;
                _yyerror("Invalid argument type.");
            } else
            {
                $1.var_attrib |= $2;
                auto* node = BUFFER_NEW(AstFunctionArg);
                node->name = $3;
                node->var_type = $1;
				node->default_value = $4;
                $$ = node;
            } 
        }
    ;

optional_and:
        // empty
        {
            $$ = 0;
        }
    |
        '&'
        {
            $$ = AST_VAR_REF_ARGUMENT;
        }
    ;

optional_question_mark:
        // empty
        {
            $$ = 0;
        }
    |
        '?'
        {
            $$ = AST_VAR_MAY_NULL;
        }
    ;

declaration:
        var_type declare_vars ';'
        {
            auto* decl = $2;

            if ($1.basic_var_type == TVOID || $1.basic_var_type == NIL)
                _yyerror("Invalid variable type.");

            // 创建赋值表达式的语法树并更新.expr的指向
            while (decl)
            {
                decl->var_type = $1;

                if (decl->expr)
                {
                    auto* assign_expr = BUFFER_NEW(AstExprAssign);
                    auto* variable = BUFFER_NEW(AstExprVariable);
                    auto* lvalue = BUFFER_NEW(AstLValue);

                    if ($1.var_attrib & AST_VAR_MAY_NULL)
                        variable->type = ValueType::MIXED;
                    else
                        variable->type = $1.basic_var_type;

                    variable->is_constant = 0;
                    variable->name = decl->name;
                    lvalue->assigner_varible = variable;
                    assign_expr->expr1 = lvalue;
                    assign_expr->expr2 = decl->expr;
                    assign_expr->op = OP_ASSIGN;

                    // Replace .expr with the assignment expression
                    decl->expr = assign_expr;
                }
                
                decl = (AstDeclare*)decl->sibling;
                STD_ASSERT(("Bad node type of decl's sibling.\n",
                            decl->get_node_type() == AstNodeType::AST_DECLARE));
            }
            $$ = decl;
        }
    ;

declare_vars:
        declare_1_var
        {
            $$ = $1;
        }
    |
        declare_1_var ',' declare_vars
        {
            $$ = (AstDeclare*)append_sibling_node($1, $3);
        }
    ;

declare_1_var:
        identifier optional_assign
        {
            auto* decl = BUFFER_NEW(AstDeclare);

            if ($2 != 0)
                decl->expr = $2;

            $$ = decl;
        }
    ;

optional_assign:
        // empty
        {
            $$ = 0;
        }
    |
        L_ASSIGN expr0
        {
            if ($1 != OP_ASSIGN)
                _yyerror("SyntaxVariable initialization operator can be only '='.");
            $$ = $2;
        }
    ;

goto:
        L_GOTO identifier ';'
        {
            // More to be added
            auto* node = BUFFER_NEW(AstGoto);
            node->goto_type = AST_DIRECT_JMP;
            node->target_label = $2;
        }
    ;

if:
        L_IF '(' single_value ')' statement optional_else_part
        {
            // Record else line
            auto* node = BUFFER_NEW(AstIfElse);
            node->cond = $3;
            node->block_then = $5;
            node->block_else = $6;
            $$ = node;
        }
    ;

optional_else_part:
        // empty
        %prec LOWER_THAN_ELSE
        {
            $$ = 0;
	    }
    |   L_ELSE statement
        {
            $$ = $2;
        }
    ;

do:
        L_DO
        {
            $<bool_flag>1 = context->m_context_state.is_in_loop;
            context->m_context_state.is_in_loop = true;
        }
        statement L_WHILE '(' single_value ')' ';'
        {
            auto* node = BUFFER_NEW(AstDoWhile);
            node->block = $3;
            node->cond = $6;
            context->m_context_state.is_in_loop = $<bool_flag>1;
        }
    ;

while:
        L_WHILE 
        {
            $<bool_flag>1 = context->m_context_state.is_in_loop;
            context->m_context_state.is_in_loop = true;
        }
        '(' single_value ')' statement
        {
            auto* node = BUFFER_NEW(AstWhileLoop);
            node->cond = $4;
            node->block = $6;
            context->m_context_state.is_in_loop = $<bool_flag>1;
        }

for:
        L_FOR '(' for_init ';' for_cond ';' for_step ')' 
        {
            $<bool_flag>1 = context->m_context_state.is_in_loop;
            context->m_context_state.is_in_loop = true;
        }
        statement
        {
            auto* node = BUFFER_NEW(AstForLoop);
            node->init = $3;
            node->cond = $5;
            node->step = $7;
            node->block = $10;
            context->m_context_state.is_in_loop = $<bool_flag>1;
        }
    |
        L_FOR '(' error ')'
        {
            _yyerror("Bad for expression/condition syntax");
        }
        statement
		{
			$$ = 0;
		}
    ;

for_init:
        // empty
        {
            $$ = 0;
        }
    |
        single_value
        {
            $$ = $1;
        }
    ;

for_cond:
        // empty
        {
            $$ = 0;
        }
    |
        single_value
        {
            $$ = $1;
        }
    ;

for_step:
        // empty
        {
            $$ = 0;
        }
    |
        single_value
        {
            $$ = $1;
        }
    ;

loop:
		L_LOOP '(' loop_init ')'
		{
            $<bool_flag>1 = context->m_context_state.is_in_loop;
            context->m_context_state.is_in_loop = true;
		}
		statement
		{
            $$ = $3;
            context->m_context_state.is_in_loop = $<bool_flag>1;
		}
	;

loop_init:
		'0' L_ASSIGN '0' to '0'
		{
            // More to be added
		}
	|
		'0' L_IN '0'
		{
            // More to be added
		}
	;

to:
		L_UPTO
		{
            $$ = 1;
		}
	|
		L_DOWNTO
		{
            $$ = -1;
		}
	;

switch:
        L_SWITCH '(' single_value ')'
        {
            $<bool_flag>1 = context->m_context_state.is_in_switch;
            context->m_context_state.is_in_switch = true;
        }
        '{' switch_block '}'
        {
            auto* node = BUFFER_NEW(AstSwitchCase);
            node->expr = $3;
            node->cases = $7;
            context->m_context_state.is_in_switch = $<bool_flag>1;
            $$ = node;
        }
    |
        L_SWITCH '(' error ')'
        {
            _yyerror("Bad parameter for switch.");
        }
        '{' switch_block '}'
        {
            $$ = 0;
        }
    ;

switch_block:
        switch_block1
        {
            $$ = $1;
        }
    |
        statement switch_block1
        {
            _yyerror("Invalid statement in the switch block.");
            $$ = $2;
        }
    ;

switch_block1:
        case switch_block1
        {
            $$ = (AstCase*)append_sibling_node($1, $2);
        }
    |
        // empty
        {
            $$ = 0;
        }
    ;

case:
        L_CASE case_label ':' statements
        {
            auto *node = BUFFER_NEW(AstCase);
            node->case_value = $2;
            node->block = $4;
            $$ = node;
        }
    |
        L_CASE error ':'
        {
            _yyerror("Invalid case label: must be constant number or string.");
        }
        statements
        {
            $$ = 0;
        }
    |
        L_DEFAULT ':' statements
        {
            auto *ca = BUFFER_NEW(AstCase);
            ca->is_default = true;
            ca->block = $3;
            $$ = ca;
        }
    |
        L_DEFAULT error ':'
        {
            _yyerror("Invalid parameter for default routine.");
        }
        statements
        {
            $$ = 0;
        }
    ;

case_label:
        constant
        {
            $$ = $1;
        }
    ;

trace:
		L_TRACE '(' comma_expression ')' ';'
		{
#ifdef _DEBUG
            // More to be added
#else
			// For release version, ignore trace action
			$$ = 0;
#endif
		}
	|
		L_TRACE '(' ')' ';'
		{
			$$ = 0;
		}
	;

shout:
		L_SHOUT '(' comma_expression ')' ';'
		{
            // More to be added
		}
	|
		L_SHOUT '(' ')' ';'
		{
			$$ = 0;
		}
	;

constant:
        expr0
        {
            $$ = $1;
            if (!$$->is_constant)
                _yyerror("Bad expression, expected constant.");
        }
    ;

catch:
        L_CATCH '(' single_value ')'
        {
            // More to be added
        }
	|
        L_CATCH block
        {
            // More to be added
        }
    ;

command:
        '\'' comma_expression ';'
        {
            // More to be added
        }
    |
        '\'' ';'
        {
            // More to be added
        }
    ;

single_value:
        comma_expression
        {
            auto* node = BUFFER_NEW(AstExprSingleValue);
            node->expr_list = $1;
            $$ = node;
        }
    ;

comma_expression:
        expr0
        {
            $$ = $1;
        }
    |
        comma_expression ',' expr0
        {
            $$ = (AstExpr*)append_sibling_node($1, $3);
        }
    ;

expr0:
        L_INC element
        {
            auto* node = BUFFER_NEW(AstExprUnary);
            node->op = OP_INC_PRE;
            node->expr1 = $2;
            $$ = node;
        }
    |
        L_DEC element
        {
            auto* node = BUFFER_NEW(AstExprUnary);
            node->op = OP_DEC_PRE;
            node->expr1 = $2;
            $$ = node;
        }
    |
        element L_INC
        {
            auto* node = BUFFER_NEW(AstExprUnary);
            node->op = OP_INC_POST;
            node->expr1 = $1;
            $$ = node;
        }
    |
        element L_DEC
        {
            auto* node = BUFFER_NEW(AstExprUnary);
            node->op = OP_DEC_POST;
            node->expr1 = $1;
            $$ = node;
        }
    |
        element L_ASSIGN expr0
        {
            auto* expr_assign = BUFFER_NEW(AstExprAssign);
            expr_assign->op = $2;
            expr_assign->expr1 = (AstLValue*)$1;////----
            expr_assign->expr2 = $3;
            $$ = expr_assign;
        }
    |
        expr0 L_LAND expr0
        {
            auto* node = BUFFER_NEW(AstExprBinary);
            node->op = OP_LAND;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |
        expr0 L_LOR expr0
        {
            auto* node = BUFFER_NEW(AstExprBinary);
            node->op = OP_LOR;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |
        expr0 L_OR expr0
        {
            auto* node = BUFFER_NEW(AstExprBinary);
            node->op = OP_OR;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_XOR expr0
        {
            auto* node = BUFFER_NEW(AstExprBinary);
            node->op = OP_XOR;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_AND expr0
        {
            auto* node = BUFFER_NEW(AstExprBinary);
            node->op = OP_AND;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_EQ expr0
        {
            auto* node = BUFFER_NEW(AstExprBinary);
            node->op = OP_EQ;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_NE expr0
        {
            auto* node = BUFFER_NEW(AstExprBinary);
            node->op = OP_NE;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_ORDER expr0
        {
            auto* node = BUFFER_NEW(AstExprBinary);
            node->op = $2;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_LT expr0
        {
            auto* node = BUFFER_NEW(AstExprBinary);
            node->op = OP_LT;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_LSH expr0
        {
            auto* node = BUFFER_NEW(AstExprBinary);
            node->op = OP_LSH;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_RSH expr0
        {
            auto* node = BUFFER_NEW(AstExprBinary);
            node->op = OP_RSH;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 '?' expr0 ':' expr0 %prec '?'
        {
            auto* node = BUFFER_NEW(AstExprTernary);
            node->op = '?';
            node->expr1 = $1;
            node->expr2 = $3;
            node->expr3 = $5;
            $$ = node;
        }
    |   expr0 L_ADD expr0
        {
            auto* node = BUFFER_NEW(AstExprBinary);
            node->op = OP_ADD;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_SUB expr0
        {
            auto* node = BUFFER_NEW(AstExprBinary);
            node->op = OP_SUB;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_MUL expr0
        {
            auto* node = BUFFER_NEW(AstExprBinary);
            node->op = OP_MUL;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_MOD expr0
        {
            auto* node = BUFFER_NEW(AstExprBinary);
            node->op = OP_MOD;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |   expr0 L_DIV expr0
        {
            auto* node = BUFFER_NEW(AstExprBinary);
            node->op = OP_DIV;
            node->expr1 = $1;
            node->expr2 = $3;
            $$ = node;
        }
    |
        L_SUB element %prec L_NOT
        {
            auto* node = BUFFER_NEW(AstExprUnary);
            node->op = OP_SUB;
            node->expr1 = $2;
            $$ = node;
        }
    |
        L_NOT element
        {
            auto* node = BUFFER_NEW(AstExprUnary);
            node->op = OP_NOT;
            node->expr1 = $2;
            $$ = node;
        }
    |
        L_REV element
        {
            auto* node = BUFFER_NEW(AstExprUnary);
            node->op = OP_REV;
            node->expr1 = $2;
            $$ = node;
        }
    |
        cast element %prec L_NOT
        {
            auto* node = BUFFER_NEW(AstExprCast);
            node->var_type = $1;
            node->expr1 = $2;
            $$ = node;
        }
    |
        element
        {
            $$ = $1;
        }
    ;

element:
        L_NIL
        {
            auto* node = BUFFER_NEW(AstExprConstant);
            node->value = Value(UNDEFINED);
            $$ = node;
        }
    |
        L_REAL
        {
            auto* node = BUFFER_NEW(AstExprConstant);
            node->value = Value($1);
            $$ = node;
        }
    |
        L_NUMBER
        {
            auto* node = BUFFER_NEW(AstExprConstant);
            node->value = Value($1);
            $$ = node;
        }
    |
        strings
        {
            auto* node = BUFFER_NEW(AstExprConstant);
            node->value = Value($1);
            $$ = node;
        }
    |
        L_FUNCTION_OPEN identifier possible_arguments ':' ')'
        {
            auto* node = BUFFER_NEW(AstExprCreateFunction);
            node->name = $2;
            node->expr_list = $3;
            $$ = node;
        }
    |
        L_ARRAY_OPEN comma_expression possible_comma '}' ')'
        {
            auto* node = BUFFER_NEW(AstExprCreateArray);
            node->expr_list = $2;
            $$ = node;
        }
    |
        L_ARRAY_OPEN possible_comma '}' ')'
        {
            auto* node = BUFFER_NEW(AstExprCreateArray);
            node->expr_list = 0;
            $$ = node;
        }
    |
        L_MAPPING_OPEN mapping_pairs ']' ')'
        {
            auto* node = BUFFER_NEW(AstExprCreateMapping);
            node->expr_list = $2;
            $$ = node;
        }
    |
        identifier
        {
            auto* node = BUFFER_NEW(AstExprVariable);
            node->name = $1;
            $$ = node;
        }
    |
       '(' single_value ')'
        {
            $$ = $2;
        }
    |
        L_CALL '(' ')'
        {
            _yyerror("Missed function to call.");
            $$ = 0;
        }
    |
        L_CALL '(' comma_expression ')'
        {
            auto* node = BUFFER_NEW(AstExprFunctionCallEx);
            node->arguments = $3;
            $$ = node;
        }
    |
        fun_call
        {
            $$ = $1;
        }
    |
        element '.' identifier
        {
            auto* node = BUFFER_NEW(AstExprSegment);
            node->expr = $1;
            node->name = $3;
            $$ = node;
        }
    |
        element '[' single_value ']'
        {
            auto* node = BUFFER_NEW(AstExprIndex);
            node->container = $1;
            node->index_from = $3;
            node->index_type = AST_INDEX_SINGLE;
            $$ = node;
        }
    |
        element '[' '<' single_value ']'
        {
            auto* node = BUFFER_NEW(AstExprIndex);
            node->container = $1;
            node->index_from = $4;
            node->index_type = AST_INDEX_SINGLE;
            node->is_reverse_from = true;
            $$ = node;
        }
    |
        element '[' single_value L_RANGE single_value ']'
        {
            auto* node = BUFFER_NEW(AstExprIndex);
            node->container = $1;
            node->index_from = $3;
            node->index_to = $5;
            node->index_type = AST_INDEX_RANGE;
            $$ = node;
        }
    |
        element '[' single_value L_RANGE '<' single_value ']'
        {
            auto* node = BUFFER_NEW(AstExprIndex);
            node->container = $1;
            node->index_from = $3;
            node->index_to = $6;
            node->index_type = AST_INDEX_RANGE;
            node->is_reverse_to = true;
            $$ = node;
        }
    |
        element '[' '<' single_value L_RANGE '<' single_value ']'
        {
            auto* node = BUFFER_NEW(AstExprIndex);
            node->container = $1;
            node->index_from = $4;
            node->index_to = $7;
            node->index_type = AST_INDEX_RANGE;
            node->is_reverse_from = true;
            node->is_reverse_to = true;
            $$ = node;
        }
    |
        '$' L_NUMBER
        {
            auto* expr = BUFFER_NEW(AstExprConstant);
            expr->value = Value($2);
            auto* node = BUFFER_NEW(AstExprUnary);
            node->expr1 = expr;
            node->op = '$';
            $$ = node;
        }
    |
        '$' '(' single_value ')'
        {
            auto* node = BUFFER_NEW(AstExprUnary);
            node->expr1 = $3;
            node->op = '$';
            $$ = node;
        }
	|
		'$' '<'
		{
            auto* node = BUFFER_NEW(AstExprRuntimeValue);
            node->var_type.basic_var_type = ARRAY;
            node->value_id = AST_RV_INPUT_ARGUMENTS;
            $$ = node;
		}
    |
        '$' '?'
        {
            auto* node = BUFFER_NEW(AstExprRuntimeValue);
            node->var_type.basic_var_type = INTEGER;
            node->value_id = AST_RV_INPUT_ARGUMENTS_COUNT;
            $$ = node;
        }
    |
        L_AND element
        {
            auto* node = BUFFER_NEW(AstExprUnary);
            node->expr1 = $2;
            node->op = OP_AND;
            $$ = node;

            ////****
            // There is a problem: If user put a non-valid type value in
            // refered value, it may cause crash
            // More to be added
        }
    |
        L_IS_REF '(' identifier ')'
        {
            auto* node = BUFFER_NEW(AstExprIsRef);
            node->name = $3;
            $$ = node;
        }
    |
        catch
        {
            $$ = $1;
        }
    ;

possible_arguments:
        // empty
        {
            $$ = 0;
        }
    |
        ',' comma_expression
        {
            $$ = $2;
        }
    ;

fun_call:
        '(' L_MUL element ')' '(' ')'
        {
            auto* node = BUFFER_NEW(AstExprFunctionCallEx);
            node->arguments = $3;
            $$ = node;
        }
    |
        '(' L_MUL element ')' '(' comma_expression ')'
        {
            auto* node = BUFFER_NEW(AstExprFunctionCallEx);
            node->arguments = (AstExpr*)append_sibling_node($3, $6);
            $$ = node;
        }
    |
        identifier '(' ')'
        {
            auto* node = BUFFER_NEW(AstExprFunctionCall);
            node->callee_name = $1;
            node->arguments = 0;
            $$ = node;
        }
    |
        identifier '(' comma_expression ')'
        {
            auto* node = BUFFER_NEW(AstExprFunctionCall);
            node->callee_name = $1;
            node->arguments = $3;
            $$ = node;
        }
    |
        element L_ARROW identifier '(' ')'
        {
            auto* node = BUFFER_NEW(AstExprFunctionCall);
            node->target = $1;
            node->callee_name = $3;
            node->arguments = NULL;
            $$ = node;
        }
    |
        element L_ARROW identifier '(' comma_expression ')'
        {
            auto* node = BUFFER_NEW(AstExprFunctionCall);
            node->target = $1;
            node->callee_name = $3;
            node->arguments = $5;
            $$ = node;
        }
    ;

mapping_pairs:
        // empty
        {
            $$ = 0;
        }
    |
        mapping_pair
        {
            $$ = $1;
        }
    |
        mapping_pair ',' mapping_pairs
        {
            $$ = (AstExpr*)append_sibling_node($1, $3);
        }
    ;

mapping_pair:
        expr0 ':' expr0
        {
            $$ = (AstExpr*)append_sibling_node($1, $3);
        }
    ;

possible_comma:
        // empty
    |
        ','
    ;

cast:
        '(' var_type ')'
        {
            if ($2.basic_var_type == TVOID || $2.basic_var_type == NIL)
                _yyerror("Invalid type to cast.");

            $$ = $2;
        }
    ;

strings:
        L_STRING
        {
            $$ = $1
        }
    |
        L_STRING strings
        {
            $$ = $1->concat($2);
        }
    ;

identifier:
        L_IDENTIFIER
        {
            $$ = $1;
        }
     ;
%%

} // End of namespace: cmm
